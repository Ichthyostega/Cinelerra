aattachmentpoint.C:	return renderengine->edl->session->audio_module_fragment;
aattachmentpoint.C:	if(plugin_server->multichannel)
aattachmentpoint.C:		plugin_servers.values[0]->process_realtime(
aattachmentpoint.C:			current_position /* - plugin->startproject */, 
aattachmentpoint.C:			plugin->length);
aattachmentpoint.C:		plugin_servers.values[buffer_number]->process_realtime(
aattachmentpoint.C:			current_position /* - plugin->startproject */, 
aattachmentpoint.C:			plugin->length);
aautomation.C:	fade_autos->create_objects();
aautomation.C:	((FloatAuto*)fade_autos->default_auto)->value = 0.0;
aautomation.C:	pan_autos->create_objects();
aboutprefs.C:		mwindow->theme->about_bg,
aboutprefs.C:	x += mwindow->theme->about_bg->get_w() + 10;
adeviceprefs.C:	this->pwindow = pwindow;
adeviceprefs.C:	this->dialog = dialog;
adeviceprefs.C:	this->driver = -1;
adeviceprefs.C:	this->mode = mode;
adeviceprefs.C:	this->out_config = out_config;
adeviceprefs.C:	this->in_config = in_config;
adeviceprefs.C:	this->x = x;
adeviceprefs.C:	this->y = y;
adeviceprefs.C:			driver = &out_config->driver;
adeviceprefs.C:			driver = &in_config->driver;
adeviceprefs.C:			driver = &out_config->driver;
adeviceprefs.C:	this->driver = *driver;
adeviceprefs.C:		dialog->add_subwindow(menu = new ADriverMenu(x, 
adeviceprefs.C:		menu->create_objects();
adeviceprefs.C:	driver = -1;
adeviceprefs.C:	alsa_drivers->remove_all_objects();
adeviceprefs.C:		int x1 = x + menu->get_w() + 5;
adeviceprefs.C://				output_int = &out_config->oss_enable[i];
adeviceprefs.C://				output_int = &in_config->oss_enable[i];
adeviceprefs.C://				output_int = &out_config->oss_enable[i];
adeviceprefs.C://		dialog->add_subwindow(oss_enable[i] = new OSSEnable(x1, y1 + 20, output_int));
adeviceprefs.C://		x1 += oss_enable[i]->get_w() + 5;
adeviceprefs.C:				output_char = out_config->oss_out_device[i];
adeviceprefs.C:				output_char = in_config->oss_in_device[i];
adeviceprefs.C:				output_char = out_config->oss_out_device[i];
adeviceprefs.C:		if(i == 0) dialog->add_subwindow(path_title = new BC_Title(x1, 
adeviceprefs.C:		dialog->add_subwindow(oss_path[i] = new ADeviceTextBox(x1, 
adeviceprefs.C:		x1 += oss_path[i]->get_w() + 5;
adeviceprefs.C:					output_int = &out_config->oss_out_bits;
adeviceprefs.C:					output_int = &in_config->oss_in_bits;
adeviceprefs.C:					output_int = &out_config->oss_out_bits;
adeviceprefs.C:			if(i == 0) dialog->add_subwindow(bits_title = new BC_Title(x1, y, _("Bits:"), MEDIUMFONT, BLACK));
adeviceprefs.C:			oss_bits->create_objects();
adeviceprefs.C:		x1 += oss_bits->get_w() + 5;
adeviceprefs.C:				output_int = &out_config->oss_out_channels[i];
adeviceprefs.C:				output_int = &in_config->oss_in_channels[i];
adeviceprefs.C:				output_int = &out_config->oss_out_channels[i];
adeviceprefs.C:		if(i == 0) dialog->add_subwindow(channels_title = new BC_Title(x1, y1, _("Channels:"), MEDIUMFONT, BLACK));
adeviceprefs.C:		dialog->add_subwindow(oss_channels[i] = new ADeviceIntBox(x1, y1 + 20, output_int));
adeviceprefs.C:	int x1 = x + menu->get_w() + 5;
adeviceprefs.C:	for(int i = 0; i < alsa_titles->total; i++)
adeviceprefs.C:		alsa_drivers->append(new BC_ListBoxItem(alsa_titles->values[i]));
adeviceprefs.C:	alsa_titles->remove_all_objects();
adeviceprefs.C:			output_char = out_config->alsa_out_device;
adeviceprefs.C:			output_char = in_config->alsa_in_device;
adeviceprefs.C:			output_char = out_config->alsa_out_device;
adeviceprefs.C:	dialog->add_subwindow(path_title = new BC_Title(x1, y, _("Device:"), MEDIUMFONT, BLACK));
adeviceprefs.C:	alsa_device->create_objects();
adeviceprefs.C:	x1 += alsa_device->get_w() + 5;
adeviceprefs.C:			output_int = &out_config->alsa_out_bits;
adeviceprefs.C:			output_int = &in_config->alsa_in_bits;
adeviceprefs.C:			output_int = &out_config->alsa_out_bits;
adeviceprefs.C:	dialog->add_subwindow(bits_title = new BC_Title(x1, y, _("Bits:"), MEDIUMFONT, BLACK));
adeviceprefs.C:	alsa_bits->create_objects();
adeviceprefs.C:	x1 += alsa_bits->get_w() + 5;
adeviceprefs.C:			output_int = &out_config->alsa_out_channels;
adeviceprefs.C:			output_int = &in_config->alsa_in_channels;
adeviceprefs.C:			output_int = &out_config->alsa_out_channels;
adeviceprefs.C:	dialog->add_subwindow(channels_title = new BC_Title(x1, y, "Channels:", MEDIUMFONT, BLACK));
adeviceprefs.C:	dialog->add_subwindow(alsa_channels = new ALSAChannels(x1, y1 + 20, output_int));
adeviceprefs.C:	int x1 = x + menu->get_w() + 5;
adeviceprefs.C:			output_char = out_config->esound_out_server;
adeviceprefs.C:			output_char = in_config->esound_in_server;
adeviceprefs.C:			output_char = out_config->esound_out_server;
adeviceprefs.C:	dialog->add_subwindow(server_title = new BC_Title(x1, y, _("Server:"), MEDIUMFONT, BLACK));
adeviceprefs.C:	dialog->add_subwindow(esound_server = new ADeviceTextBox(x1, y + 20, output_char));
adeviceprefs.C:			output_int = &out_config->esound_out_port;
adeviceprefs.C:			output_int = &in_config->esound_in_port;
adeviceprefs.C:			output_int = &out_config->esound_out_port;
adeviceprefs.C:	x1 += esound_server->get_w() + 5;
adeviceprefs.C:	dialog->add_subwindow(port_title = new BC_Title(x1, y, _("Port:"), MEDIUMFONT, BLACK));
adeviceprefs.C:	dialog->add_subwindow(esound_port = new ADeviceIntBox(x1, y + 20, output_int));
adeviceprefs.C:	int x1 = x + menu->get_w() + 5;
adeviceprefs.C:				output_char = out_config->dv1394_path;
adeviceprefs.C:				output_char = out_config->firewire_path;
adeviceprefs.C:		dialog->add_subwindow(path_title = new BC_Title(x1, y, _("Device Path:"), MEDIUMFONT, BLACK));
adeviceprefs.C:		dialog->add_subwindow(firewire_path = new ADeviceTextBox(x1, y + 20, output_char));
adeviceprefs.C:		x1 += firewire_path->get_w() + 5;
adeviceprefs.C:				output_int = &out_config->dv1394_port;
adeviceprefs.C:				output_int = &out_config->firewire_port;
adeviceprefs.C:			output_int = &in_config->firewire_port;
adeviceprefs.C://			output_int = &out_config->afirewire_out_port;
adeviceprefs.C:	dialog->add_subwindow(port_title = new BC_Title(x1, y, _("Port:"), MEDIUMFONT, BLACK));
adeviceprefs.C:	dialog->add_subwindow(firewire_port = new ADeviceIntBox(x1, y + 20, output_int));
adeviceprefs.C:	x1 += firewire_port->get_w() + 5;
adeviceprefs.C:				output_int = &out_config->dv1394_channel;
adeviceprefs.C:				output_int = &out_config->firewire_channel;
adeviceprefs.C:			output_int = &in_config->firewire_channel;
adeviceprefs.C:	dialog->add_subwindow(channel_title = new BC_Title(x1, y, _("Channel:"), MEDIUMFONT, BLACK));
adeviceprefs.C:	dialog->add_subwindow(firewire_channel = new ADeviceIntBox(x1, y + 20, output_int));
adeviceprefs.C:	x1 += firewire_channel->get_w() + 5;
adeviceprefs.C:				output_int = &out_config->dv1394_channels;
adeviceprefs.C:				output_int = &out_config->firewire_channels;
adeviceprefs.C:		dialog->add_subwindow(channels_title = new BC_Title(x1, y, _("Channels:"), MEDIUMFONT, BLACK));
adeviceprefs.C:		dialog->add_subwindow(firewire_channels = new ADeviceIntBox(x1, y + 20, output_int));
adeviceprefs.C:		x1 += firewire_channels->get_w() + 5;
adeviceprefs.C:				output_int = &out_config->dv1394_syt;
adeviceprefs.C:				output_int = &out_config->firewire_syt;
adeviceprefs.C:		dialog->add_subwindow(syt_title = new BC_Title(x1, y, _("Syt Offset:"), MEDIUMFONT, BLACK));
adeviceprefs.C:		dialog->add_subwindow(firewire_syt = new ADeviceIntBox(x1, y + 20, output_int));
adeviceprefs.C:		x1 += firewire_syt->get_w() + 5;
adeviceprefs.C:	this->output = output;
adeviceprefs.C:	this->do_input = do_input;
adeviceprefs.C:	this->device_prefs = device_prefs;
adeviceprefs.C:	this->popup = popup;
adeviceprefs.C:	this->driver = driver;
adeviceprefs.C:	popup->set_text(get_text());
adeviceprefs.C:	*(popup->output) = driver;
adeviceprefs.C:	popup->device_prefs->initialize();
adeviceprefs.C:	this->output = output;
adeviceprefs.C:	this->output = output; 
adeviceprefs.C:	this->output = output;
adeviceprefs.C:	this->output = output;
aedit.C:	channel = xml->tag.get_property("CHANNEL", (int32_t)0);
aedit.C:	return (int64_t)((double)asset->audio_length / asset->sample_rate * edl->session->sample_rate + 0.5);
aedits.C://printf("AEdits::insert_edit_after %p %p\n", current->track, current->edits);
amodule.C:		level_history = new double[((ARender*)commonrender)->history_size()];
amodule.C:		level_samples = new int64_t[((ARender*)commonrender)->history_size()];
amodule.C:		for(int i = 0; i < ((ARender*)commonrender)->history_size(); i++)
amodule.C:			level_samples[i] = -1;
amodule.C:	return get_edl()->session->audio_module_fragment;
amodule.C:	for(start = 0, end = len - 1; end > start; start++, end--)
amodule.C:		return renderengine->get_acache();
amodule.C:	if(use_nudge) input_position += track->nudge;
amodule.C:		start_project -= input_len;
amodule.C:		end_project -= input_len;
amodule.C:	for(playable_edit = (AEdit*)track->edits->first; 
amodule.C:		playable_edit = (AEdit*)playable_edit->next)
amodule.C:		double edit_start = playable_edit->startproject;
amodule.C:		double edit_end = playable_edit->startproject + playable_edit->length;
amodule.C:			fragment_len = end_project - start_project;
amodule.C:				playable_edit->startproject + playable_edit->length)
amodule.C:				fragment_len = playable_edit->startproject + 
amodule.C:					playable_edit->length - start_project;
amodule.C:			if(playable_edit->asset)
amodule.C:				if(!(source = get_cache()->check_out(playable_edit->asset)))
amodule.C:					printf(_("VirtualAConsole::load_track Couldn't open %s.\n"), playable_edit->asset->path);
amodule.C:					result = source->set_audio_position(start_project - 
amodule.C:							playable_edit->startproject + 
amodule.C:							playable_edit->startsource, 
amodule.C:						get_edl()->session->sample_rate);
amodule.C:					if(result) printf("AModule::render start_project=%d playable_edit->startproject=%d playable_edit->startsource=%d\n"
amodule.C:						start_project, playable_edit->startproject, playable_edit->startsource, 
amodule.C:						source, playable_edit, get_edl(), get_edl()->session, get_edl()->session->sample_rate);
amodule.C:					source->set_channel(playable_edit->channel);
amodule.C:					source->read_samples(buffer + buffer_offset, 
amodule.C:						get_edl()->session->sample_rate);
amodule.C:					get_cache()->check_in(playable_edit->asset);
amodule.C:			AEdit *previous_edit = (AEdit*)playable_edit->previous;
amodule.C:					transition_temp = new double[get_edl()->session->audio_read_length];
amodule.C:					playable_edit->startproject + transition->length)
amodule.C:					fragment_len = playable_edit->startproject + 
amodule.C:						playable_edit->transition->length - 
amodule.C:					if(previous_edit->asset)
amodule.C:						if(!(source = get_cache()->check_out(previous_edit->asset)))
amodule.C:							printf(_("VirtualAConsole::load_track Couldn't open %s.\n"), playable_edit->asset->path);
amodule.C:							result = source->set_audio_position(start_project - 
amodule.C:									previous_edit->startproject + 
amodule.C:									previous_edit->startsource, 
amodule.C:								get_edl()->session->sample_rate);
amodule.C:							if(result) printf("AModule::render start_project=%d playable_edit->startproject=%d playable_edit->startsource=%d\n"
amodule.C:								previous_edit->startproject, 
amodule.C:								previous_edit->startsource, 
amodule.C:								get_edl()->session, 
amodule.C:								get_edl()->session->sample_rate);
amodule.C:							source->set_channel(previous_edit->channel);
amodule.C:							source->read_samples(transition_temp, 
amodule.C:								get_edl()->session->sample_rate);
amodule.C:							get_cache()->check_in(previous_edit->asset);
amodule.C:					transition_server->process_realtime(
amodule.C:						start_project - playable_edit->startproject,
amodule.C:						transition->length);
amodule.C:			start_project >= playable_edit->startproject + playable_edit->length)
amodule.C:			playable_edit = (AEdit*)playable_edit->next;
apanel.C:	this->mwindow = mwindow;
apanel.C:	this->subwindow = subwindow;
apanel.C:	this->x = x;
apanel.C:	this->y = y;
apanel.C:	this->w = w;
apanel.C:	this->h = h;
apanel.C:	int x = this->x + 5, y = this->y + 10;
apanel.C:	subwindow->add_subwindow(new BC_Title(x, y, _("Automation")));
apanel.C:		subwindow->add_subwindow(new BC_Title(x, y, string, SMALLFONT));
apanel.C:		subwindow->add_subwindow(plugin_autos[i] = new APanelPluginAuto(mwindow, this, x, y + 20));
apanel.C:			x += plugin_autos[i]->get_w();
apanel.C:			y += plugin_autos[i]->get_h() + 20;
apanel.C:	subwindow->add_subwindow(mute = new APanelMute(mwindow, this, x, y));
apanel.C:	y += mute->get_h();
apanel.C:	subwindow->add_subwindow(play = new APanelPlay(mwindow, this, x, y));
apanel.C:		-1, 
apanel.C:	this->mwindow = mwindow;
apanel.C:	this->gui = gui;
apanel.C:	this->mwindow = mwindow;
apanel.C:	this->gui = gui;
apanel.C:	this->mwindow = mwindow;
apanel.C:	this->gui = gui;
apatchgui.C:	this->atrack = track;
apatchgui.C:	if(fade) fade->reposition_window(fade->get_x(), 
apatchgui.C:	y1 += mwindow->theme->fade_h;
apatchgui.C:	if(meter) meter->reposition_window(meter->get_x(),
apatchgui.C:		meter->get_w());
apatchgui.C:	y1 += mwindow->theme->meter_h;
apatchgui.C:	if(pan) pan->reposition_window(pan->get_x(),
apatchgui.C:	if(nudge) nudge->reposition_window(nudge->get_x(),
apatchgui.C:	y1 += mwindow->theme->pan_h;
apatchgui.C:	int h = track->vertical_span(mwindow->theme);
apatchgui.C:		if(h - y1 < mwindow->theme->fade_h)
apatchgui.C://printf("APatchGUI::update %f\n", fade->get_keyframe(mwindow, this)->value);
apatchgui.C:			double unit_position = mwindow->edl->local_session->selectionstart;
apatchgui.C:			unit_position = mwindow->edl->align_to_frame(unit_position, 0);
apatchgui.C:			unit_position = atrack->to_units(unit_position, 0);
apatchgui.C:			float value = atrack->automation->fade_autos->get_value(
apatchgui.C:			fade->update(value);
apatchgui.C://			fade->update(fade->get_keyframe(mwindow, this)->value);
apatchgui.C:	if(h - y1 >= mwindow->theme->fade_h)
apatchgui.C:		patchbay->add_subwindow(fade = new AFadePatch(mwindow, 
apatchgui.C:			patchbay->get_w() - 10));
apatchgui.C:	y1 += mwindow->theme->fade_h;
apatchgui.C:		if(h - y1 < mwindow->theme->meter_h)
apatchgui.C:	if(h - y1 >= mwindow->theme->meter_h)
apatchgui.C:		patchbay->add_subwindow(meter = new AMeterPatch(mwindow,
apatchgui.C:	y1 += mwindow->theme->meter_h;
apatchgui.C:		if(h - y1 < mwindow->theme->pan_h)
apatchgui.C:			if(pan->get_total_values() != mwindow->edl->session->audio_channels)
apatchgui.C:				pan->change_channels(mwindow->edl->session->audio_channels,
apatchgui.C:					mwindow->edl->session->achannel_positions);
apatchgui.C:				double unit_position = mwindow->edl->local_session->selectionstart;
apatchgui.C:				unit_position = mwindow->edl->align_to_frame(unit_position, 0);
apatchgui.C:				unit_position = atrack->to_units(unit_position, 0);
apatchgui.C:				atrack->automation->pan_autos->get_handle(handle_x,
apatchgui.C:				pan->update(handle_x, handle_y);
apatchgui.C:			nudge->update();
apatchgui.C:	if(h - y1 >= mwindow->theme->pan_h)
apatchgui.C:		patchbay->add_subwindow(pan = new APanPatch(mwindow,
apatchgui.C:		x1 += pan->get_w() + 10;
apatchgui.C:		patchbay->add_subwindow(nudge = new NudgePatch(mwindow,
apatchgui.C:			patchbay->get_w() - x1 - 10));
apatchgui.C:	y1 += mwindow->theme->pan_h;
apatchgui.C:		fade->update(fade->get_value() + value_change);
apatchgui.C:		fade->update_edl();
apatchgui.C:			get_keyframe(mwindow, patch)->value)
apatchgui.C://printf("AFadePatch::AFadePatch 1 %p %f\n", patch->track, get_keyframe(mwindow, patch)->value);
apatchgui.C://printf("AFadePatch::AFadePatch 2 %f\n", ((FloatAuto*)patch->track->automation->fade_autos->first)->value);
apatchgui.C:	this->mwindow = mwindow;
apatchgui.C:	this->patch = patch;
apatchgui.C:	double position = mwindow->edl->local_session->selectionstart;
apatchgui.C:	Autos *fade_autos = patch->atrack->automation->fade_autos;
apatchgui.C:	int update_undo = !fade_autos->auto_exists_for_editing(position);
apatchgui.C:		mwindow->undo->update_undo_before(_("fade"), LOAD_AUTOMATION);
apatchgui.C:	current = (FloatAuto*)fade_autos->get_auto_for_editing(position);
apatchgui.C:	float result = get_value() - current->value;
apatchgui.C:	current->value = get_value();
apatchgui.C:		mwindow->undo->update_undo_after();
apatchgui.C:	patch->change_source = 1;
apatchgui.C:	if(patch->track->gang) 
apatchgui.C:		patch->patchbay->synchronize_faders(change, TRACK_AUDIO, patch->track);
apatchgui.C:	patch->change_source = 0;
apatchgui.C:	mwindow->sync_parameters(CHANGE_PARAMS);
apatchgui.C:	if(mwindow->edl->session->auto_conf->fade)
apatchgui.C:		mwindow->gui->canvas->draw_overlays();
apatchgui.C:		mwindow->gui->canvas->flash();
apatchgui.C:	double unit_position = mwindow->edl->local_session->selectionstart;
apatchgui.C:	unit_position = mwindow->edl->align_to_frame(unit_position, 0);
apatchgui.C:	unit_position = patch->atrack->to_units(unit_position, 0);
apatchgui.C:	return (FloatAuto*)patch->atrack->automation->fade_autos->get_prev_auto(
apatchgui.C:		mwindow->edl->session->audio_channels, 
apatchgui.C:		mwindow->edl->session->achannel_positions, 
apatchgui.C:		get_keyframe(mwindow, patch)->handle_x, 
apatchgui.C:		get_keyframe(mwindow, patch)->handle_y,
apatchgui.C: 		get_keyframe(mwindow, patch)->values)
apatchgui.C:	this->mwindow = mwindow;
apatchgui.C:	this->patch = patch;
apatchgui.C:	double position = mwindow->edl->local_session->selectionstart;
apatchgui.C:	Autos *pan_autos = patch->atrack->automation->pan_autos;
apatchgui.C:	int update_undo = !pan_autos->auto_exists_for_editing(position);
apatchgui.C:		mwindow->undo->update_undo_before(_("pan"), LOAD_AUTOMATION);
apatchgui.C:	current = (PanAuto*)pan_autos->get_auto_for_editing(position);
apatchgui.C:	current->handle_x = get_stick_x();
apatchgui.C:	current->handle_y = get_stick_y();
apatchgui.C:	memcpy(current->values, get_values(), sizeof(float) * mwindow->edl->session->audio_channels);
apatchgui.C:		mwindow->undo->update_undo_after();
apatchgui.C:	mwindow->sync_parameters(CHANGE_PARAMS);
apatchgui.C:	if(update_undo && mwindow->edl->session->auto_conf->pan)
apatchgui.C:		mwindow->gui->canvas->draw_overlays();
apatchgui.C:		mwindow->gui->canvas->flash();
apatchgui.C:	double unit_position = mwindow->edl->local_session->selectionstart;
apatchgui.C:	unit_position = mwindow->edl->align_to_frame(unit_position, 0);
apatchgui.C:	unit_position = patch->atrack->to_units(unit_position, 0);
apatchgui.C:	return (PanAuto*)patch->atrack->automation->pan_autos->get_prev_auto(
apatchgui.C:			patch->patchbay->get_w() - 10, 
apatchgui.C:			mwindow->edl->session->min_meter_db, 
apatchgui.C:			mwindow->edl->session->meter_format, 
apatchgui.C:			mwindow->edl->session->record_speed * 10,
apatchgui.C:			mwindow->edl->session->record_speed)
apatchgui.C:	this->mwindow = mwindow;
apatchgui.C:	this->patch = patch;
apatchgui.C:		mwindow->reset_meters();
apluginarray.C:	file->stop_audio_thread();
apluginarray.C:	file->start_audio_thread(buffer_size, RING_BUFFERS);
apluginarray.C://	if(!plugin_server->realtime) realtime_buffers = file->get_audio_buffer();
apluginarray.C:		modules[i] = new AModule(0, 0, this, tracks->values[i]);
apluginarray.C:		modules[i]->cache = cache;
apluginarray.C:		modules[i]->edl = edl;
apluginarray.C:		modules[i]->create_objects();
apluginarray.C:		modules[i]->render_init();
apluginarray.C:	if(module == 0) realtime_buffers = file->get_audio_buffer();
apluginarray.C:	((AModule*)modules[module])->render(realtime_buffers[module], 
apluginarray.C:	values[module]->process_realtime(realtime_buffers + module, 
apluginarray.C:	if(!realtime_buffers) realtime_buffers = file->get_audio_buffer();
apluginarray.C:	int result = values[module]->process_loop(&realtime_buffers[module], 
apluginarray.C:	int result = file->write_audio_buffer(len);
apluginarray.C://	if(!plugin_server->realtime && !done && !result) 
apluginarray.C://		realtime_buffers = file->get_audio_buffer();
apluginarray.C:	return mwindow->edl->session->sample_rate;
apluginarray.C:	tracks = new RecordableATracks(mwindow->edl->tracks);
apluginarray.C:	return tracks->total;
apluginarray.C:	return (Track*)tracks->values[number];
apluginthread.C:	this->plugin_server = new PluginServer(*plugin_server);
apluginthread.C:	plugin_server->open_plugin();
apluginthread.C:	plugin_server->start_gui();
apluginthread.C:printf("plugin_server->stop_gui\n");
apluginthread.C:		plugin_server->stop_gui();     // sends a completed command to the thread
apluginthread.C:printf("plugin_server->close_plugin\n");
apluginthread.C:		plugin_server->close_plugin();        // tell client thread to finish
apluginthread.C:printf("done plugin_server->close_plugin\n");
arender.C:	return renderengine->edl->tracks->total_audio_tracks();
arender.C:		meter_render_fragment = renderengine->edl->session->audio_module_fragment;
arender.C:		while(meter_render_fragment > renderengine->edl->session->sample_rate / 10) 
arender.C:			renderengine->edl->session->audio_read_length / 
arender.C:		level_samples[i] = -1;
arender.C://printf("ARender::init_output_buffers %d\n", renderengine->adjusted_fragment_len);
arender.C:	if(renderengine->command->realtime)
arender.C://printf("ARender::init_output_buffers %d %d\n", i, renderengine->config->aconfig->do_channel[i]);
arender.C:			if(renderengine->config->aconfig->do_channel[i])
arender.C:				audio_out[i] = new double[renderengine->adjusted_fragment_len];
arender.C:		return Units::round(position * renderengine->edl->session->sample_rate);
arender.C:		return (int64_t)(position * renderengine->edl->session->sample_rate);
arender.C:	return (double)position / renderengine->edl->session->sample_rate;
arender.C:	this->last_playback = last_buffer;
arender.C:				this->audio_out[i] = buffer_out[i] + fragment_position;
arender.C:				this->audio_out[i] = 0;
arender.C:			fragment_len = input_len - fragment_position;
arender.C:		reconfigure = vconsole->test_reconfigure(input_position, 
arender.C:	bzero(this->audio_out, sizeof(double*) * MAXCHANNELS);
arender.C:	int result = ((VirtualAConsole*)vconsole)->process_buffer(input_len,
arender.C:		vconsole->wait_for_completion();
arender.C:		if(labs(table[i] - position) < min_difference)
arender.C:			min_difference = labs(table[i] - position);
arender.C:	renderengine->audio->wait_for_completion();
arender.C:	start_lock->unlock();
arender.C:		current_input_length = renderengine->edl->session->audio_read_length;
arender.C:			reconfigure = vconsole->test_reconfigure(current_position, 
arender.C:		if(renderengine->command->realtime && 
arender.C:			renderengine->playback_engine &&
arender.C:			!renderengine->do_video)
arender.C:			double position = (double)renderengine->audio->current_position() / 
arender.C:				renderengine->edl->session->sample_rate * 
arender.C:				renderengine->command->get_speed();
arender.C:			if(renderengine->command->get_direction() == PLAY_FORWARD) 
arender.C:				position += renderengine->command->playbackstart;
arender.C:				position = renderengine->command->playbackstart - position;
arender.C:			renderengine->playback_engine->update_tracking(position);
arender.C:		if(vconsole->interrupt) interrupt = 1;
arender.C:	if(renderengine->command->realtime) wait_device_completion();
arender.C:	vconsole->stop_rendering(0);
arender.C:	this->current_position = current_position;
arender.C:	this->input_length = input_length;
arender.C:	source_length = renderengine->end_position - renderengine->start_position;
arender.C:	if(renderengine->command->realtime)
arender.C:		Thread::set_realtime(renderengine->edl->session->real_time_playback);
arender.C:	if(renderengine->command->realtime)	
arender.C:	if(renderengine->command->realtime)
arender.C:		vconsole->output_lock[vconsole->current_input_buffer]->lock();
arender.C:		vconsole->input_len[vconsole->current_input_buffer] = 0;
arender.C:		vconsole->input_position[vconsole->current_input_buffer] = 0;
arender.C:		vconsole->last_playback[vconsole->current_input_buffer] = 0;
arender.C:		vconsole->last_reconfigure[vconsole->current_input_buffer] = 1;
arender.C:		vconsole->input_lock[vconsole->current_input_buffer]->unlock();
arender.C:		vconsole->swap_input_buffer();
arender.C:	for(start = 0, end = len - 1; end > start; start++, end--)
asset.C:	strcpy(this->path, path);
asset.C:	vorbis_min_bitrate = -1;
asset.C:	vorbis_max_bitrate = -1;
asset.C:	strcpy(this->path, asset->path);
asset.C:	strcpy(this->folder, asset->folder);
asset.C:	audio_data = asset->audio_data;
asset.C:	format = asset->format;
asset.C:	channels = asset->channels;
asset.C:	sample_rate = asset->sample_rate;
asset.C:	bits = asset->bits;
asset.C:	byte_order = asset->byte_order;
asset.C:	signed_ = asset->signed_;
asset.C:	header = asset->header;
asset.C:	dither = asset->dither;
asset.C:	mp3_bitrate = asset->mp3_bitrate;
asset.C:	use_header = asset->use_header;
asset.C:	video_data = asset->video_data;
asset.C:	layers = asset->layers;
asset.C:	frame_rate = asset->frame_rate;
asset.C:	width = asset->width;
asset.C:	height = asset->height;
asset.C:	strcpy(vcodec, asset->vcodec);
asset.C:	strcpy(acodec, asset->acodec);
asset.C:	this->audio_length = asset->audio_length;
asset.C:	this->video_length = asset->video_length;
asset.C:	ampeg_bitrate = asset->ampeg_bitrate;
asset.C:	ampeg_derivative = asset->ampeg_derivative;
asset.C:	vorbis_vbr = asset->vorbis_vbr;
asset.C:	vorbis_min_bitrate = asset->vorbis_min_bitrate;
asset.C:	vorbis_bitrate = asset->vorbis_bitrate;
asset.C:	vorbis_max_bitrate = asset->vorbis_max_bitrate;
asset.C:	jpeg_quality = asset->jpeg_quality;
asset.C:	vmpeg_iframe_distance = asset->vmpeg_iframe_distance;
asset.C:	vmpeg_bframe_distance = asset->vmpeg_bframe_distance;
asset.C:	vmpeg_progressive = asset->vmpeg_progressive;
asset.C:	vmpeg_denoise = asset->vmpeg_denoise;
asset.C:	vmpeg_bitrate = asset->vmpeg_bitrate;
asset.C:	vmpeg_derivative = asset->vmpeg_derivative;
asset.C:	vmpeg_quantization = asset->vmpeg_quantization;
asset.C:	vmpeg_cmodel = asset->vmpeg_cmodel;
asset.C:	vmpeg_fix_bitrate = asset->vmpeg_fix_bitrate;
asset.C:	vmpeg_seq_codes = asset->vmpeg_seq_codes;
asset.C:	divx_bitrate = asset->divx_bitrate;
asset.C:	divx_rc_period = asset->divx_rc_period;
asset.C:	divx_rc_reaction_ratio = asset->divx_rc_reaction_ratio;
asset.C:	divx_rc_reaction_period = asset->divx_rc_reaction_period;
asset.C:	divx_max_key_interval = asset->divx_max_key_interval;
asset.C:	divx_max_quantizer = asset->divx_max_quantizer;
asset.C:	divx_min_quantizer = asset->divx_min_quantizer;
asset.C:	divx_quantizer = asset->divx_quantizer;
asset.C:	divx_quality = asset->divx_quality;
asset.C:	divx_fix_bitrate = asset->divx_fix_bitrate;
asset.C:	divx_use_deblocking = asset->divx_use_deblocking;
asset.C:	ms_bitrate = asset->ms_bitrate;
asset.C:	ms_bitrate_tolerance = asset->ms_bitrate_tolerance;
asset.C:	ms_interlaced = asset->ms_interlaced;
asset.C:	ms_quantization = asset->ms_quantization;
asset.C:	ms_gop_size = asset->ms_gop_size;
asset.C:	ms_fix_bitrate = asset->ms_fix_bitrate;
asset.C:	png_use_alpha = asset->png_use_alpha;
asset.C:	if(!strcasecmp(this->path, path)) 
asset.C:			fs.extract_dir(input_directory, file->filename);
asset.C:		result = file->read_tag();
asset.C:			if(file->tag.title_is("/ASSET"))
asset.C:			if(file->tag.title_is("AUDIO"))
asset.C:			if(file->tag.title_is("FORMAT"))
asset.C:				char *string = file->tag.get_property("TYPE");
asset.C:					file->tag.get_property("USE_HEADER", use_header);
asset.C:			if(file->tag.title_is("FOLDER"))
asset.C:				strcpy(folder, file->read_text());
asset.C:			if(file->tag.title_is("VIDEO"))
asset.C:			if(file->tag.title_is("INDEX"))
asset.C:	channels = file->tag.get_property("CHANNELS", 2);
asset.C:	if(!sample_rate) sample_rate = file->tag.get_property("RATE", 44100);
asset.C:	bits = file->tag.get_property("BITS", 16);
asset.C:	byte_order = file->tag.get_property("BYTE_ORDER", 1);
asset.C:	signed_ = file->tag.get_property("SIGNED", 1);
asset.C:	header = file->tag.get_property("HEADER", 0);
asset.C:	dither = file->tag.get_property("DITHER", 0);
asset.C:	audio_length = file->tag.get_property("AUDIO_LENGTH", 0);
asset.C:	file->tag.get_property("ACODEC", acodec);
asset.C:	ampeg_bitrate = file->tag.get_property("AMPEG_BITRATE", ampeg_bitrate);
asset.C:	ampeg_derivative = file->tag.get_property("AMPEG_DERIVATIVE", ampeg_derivative);
asset.C:	vorbis_vbr = file->tag.get_property("VORBIS_VBR", vorbis_vbr);
asset.C:	vorbis_min_bitrate = file->tag.get_property("VORBIS_MIN_BITRATE", vorbis_min_bitrate);
asset.C:	vorbis_bitrate = file->tag.get_property("VORBIS_BITRATE", vorbis_bitrate);
asset.C:	vorbis_max_bitrate = file->tag.get_property("VORBIS_MAX_BITRATE", vorbis_max_bitrate);
asset.C:	mp3_bitrate = file->tag.get_property("MP3_BITRATE", mp3_bitrate);
asset.C:	height = file->tag.get_property("HEIGHT", height);
asset.C:	width = file->tag.get_property("WIDTH", width);
asset.C:	layers = file->tag.get_property("LAYERS", layers);
asset.C:	if(!frame_rate) frame_rate = file->tag.get_property("FRAMERATE", frame_rate);
asset.C:	file->tag.get_property("VCODEC", vcodec);
asset.C:	video_length = file->tag.get_property("VIDEO_LENGTH", 0);
asset.C:	jpeg_quality = file->tag.get_property("JPEG_QUALITY", jpeg_quality);
asset.C:	vmpeg_iframe_distance = file->tag.get_property("VMPEG_IFRAME_DISTANCE", vmpeg_iframe_distance);
asset.C:	vmpeg_bframe_distance = file->tag.get_property("VMPEG_BFRAME_DISTANCE", vmpeg_bframe_distance);
asset.C:	vmpeg_progressive = file->tag.get_property("VMPEG_PROGRESSIVE", vmpeg_progressive);
asset.C:	vmpeg_denoise = file->tag.get_property("VMPEG_DENOISE", vmpeg_denoise);
asset.C:	vmpeg_bitrate = file->tag.get_property("VMPEG_BITRATE", vmpeg_bitrate);
asset.C:	vmpeg_derivative = file->tag.get_property("VMPEG_DERIVATIVE", vmpeg_derivative);
asset.C:	vmpeg_quantization = file->tag.get_property("VMPEG_QUANTIZATION", vmpeg_quantization);
asset.C:	vmpeg_cmodel = file->tag.get_property("VMPEG_CMODEL", vmpeg_cmodel);
asset.C:	vmpeg_fix_bitrate = file->tag.get_property("VMPEG_FIX_BITRATE", vmpeg_fix_bitrate);
asset.C:	vmpeg_seq_codes = file->tag.get_property("VMPEG_SEQ_CODES", vmpeg_seq_codes);
asset.C:	divx_bitrate = file->tag.get_property("DIVX_BITRATE", divx_bitrate);
asset.C:	divx_rc_period = file->tag.get_property("DIVX_RC_PERIOD", divx_rc_period);
asset.C:	divx_rc_reaction_ratio = file->tag.get_property("DIVX_RC_REACTION_RATIO", divx_rc_reaction_ratio);
asset.C:	divx_rc_reaction_period = file->tag.get_property("DIVX_RC_REACTION_PERIOD", divx_rc_reaction_period);
asset.C:	divx_max_key_interval = file->tag.get_property("DIVX_MAX_KEY_INTERVAL", divx_max_key_interval);
asset.C:	divx_max_quantizer = file->tag.get_property("DIVX_MAX_QUANTIZER", divx_max_quantizer);
asset.C:	divx_min_quantizer = file->tag.get_property("DIVX_MIN_QUANTIZER", divx_min_quantizer);
asset.C:	divx_quantizer = file->tag.get_property("DIVX_QUANTIZER", divx_quantizer);
asset.C:	divx_quality = file->tag.get_property("DIVX_QUALITY", divx_quality);
asset.C:	divx_fix_bitrate = file->tag.get_property("DIVX_FIX_BITRATE", divx_fix_bitrate);
asset.C:	divx_use_deblocking = file->tag.get_property("DIVX_USE_DEBLOCKING", divx_use_deblocking);
asset.C:	ms_bitrate = file->tag.get_property("MS_BITRATE", ms_bitrate);
asset.C:	ms_bitrate_tolerance = file->tag.get_property("MS_BITRATE_TOLERANCE", ms_bitrate_tolerance);
asset.C:	ms_interlaced = file->tag.get_property("MS_INTERLACED", ms_interlaced);
asset.C:	ms_quantization = file->tag.get_property("MS_QUANTIZATION", ms_quantization);
asset.C:	ms_gop_size = file->tag.get_property("MS_GOP_SIZE", ms_gop_size);
asset.C:	ms_fix_bitrate = file->tag.get_property("MS_FIX_BITRATE", ms_fix_bitrate);
asset.C:	png_use_alpha = file->tag.get_property("PNG_USE_ALPHA", png_use_alpha);
asset.C:	index_zoom = file->tag.get_property("ZOOM", 1);
asset.C:	index_bytes = file->tag.get_property("BYTES", (int64_t)0);
asset.C:		result = file->read_tag();
asset.C:			if(file->tag.title_is("/INDEX"))
asset.C:			if(file->tag.title_is("OFFSET"))
asset.C:					index_offsets[current_offset++] = file->tag.get_property("FLOAT", 0);
asset.C://printf("Asset::read_index %d %d\n", current_offset - 1, index_offsets[current_offset - 1]);
asset.C:	file->tag.set_title("ASSET");
asset.C:	file->tag.set_property("SRC", new_path);
asset.C:	file->append_tag();
asset.C:	file->append_newline();
asset.C:	file->tag.set_title("FOLDER");
asset.C:	file->append_tag();
asset.C:	file->append_text(folder);
asset.C:	file->tag.set_title("/FOLDER");
asset.C:	file->append_tag();
asset.C:	file->append_newline();
asset.C:	file->tag.set_title("FORMAT");
asset.C:	file->tag.set_property("TYPE", 
asset.C:	file->tag.set_property("USE_HEADER", use_header);
asset.C:	file->append_tag();
asset.C:	file->append_newline();
asset.C:	file->tag.set_title("/ASSET");
asset.C:	file->append_tag();
asset.C:	file->append_newline();
asset.C:	file->tag.set_title("AUDIO");
asset.C:	file->tag.set_property("CHANNELS", channels);
asset.C:	file->tag.set_property("RATE", sample_rate);
asset.C:	file->tag.set_property("BITS", bits);
asset.C:	file->tag.set_property("BYTE_ORDER", byte_order);
asset.C:	file->tag.set_property("SIGNED", signed_);
asset.C:	file->tag.set_property("HEADER", header);
asset.C:	file->tag.set_property("DITHER", dither);
asset.C:		file->tag.set_property("ACODEC", acodec);
asset.C:	file->tag.set_property("AUDIO_LENGTH", audio_length);
asset.C:	file->tag.set_property("AMPEG_BITRATE", ampeg_bitrate);
asset.C:	file->tag.set_property("AMPEG_DERIVATIVE", ampeg_derivative);
asset.C:	file->tag.set_property("VORBIS_VBR", vorbis_vbr);
asset.C:	file->tag.set_property("VORBIS_MIN_BITRATE", vorbis_min_bitrate);
asset.C:	file->tag.set_property("VORBIS_BITRATE", vorbis_bitrate);
asset.C:	file->tag.set_property("VORBIS_MAX_BITRATE", vorbis_max_bitrate);
asset.C:	file->tag.set_property("MP3_BITRATE", mp3_bitrate);
asset.C:	file->append_tag();
asset.C:	file->append_newline();
asset.C:	file->tag.set_title("VIDEO");
asset.C:	file->tag.set_property("HEIGHT", height);
asset.C:	file->tag.set_property("WIDTH", width);
asset.C:	file->tag.set_property("LAYERS", layers);
asset.C:	file->tag.set_property("FRAMERATE", frame_rate);
asset.C:		file->tag.set_property("VCODEC", vcodec);
asset.C:	file->tag.set_property("VIDEO_LENGTH", video_length);
asset.C:	file->tag.set_property("JPEG_QUALITY", jpeg_quality);
asset.C:	file->tag.set_property("VMPEG_IFRAME_DISTANCE", vmpeg_iframe_distance);
asset.C:	file->tag.set_property("VMPEG_BFRAME_DISTANCE", vmpeg_bframe_distance);
asset.C:	file->tag.set_property("VMPEG_PROGRESSIVE", vmpeg_progressive);
asset.C:	file->tag.set_property("VMPEG_DENOISE", vmpeg_denoise);
asset.C:	file->tag.set_property("VMPEG_BITRATE", vmpeg_bitrate);
asset.C:	file->tag.set_property("VMPEG_DERIVATIVE", vmpeg_derivative);
asset.C:	file->tag.set_property("VMPEG_QUANTIZATION", vmpeg_quantization);
asset.C:	file->tag.set_property("VMPEG_CMODEL", vmpeg_cmodel);
asset.C:	file->tag.set_property("VMPEG_FIX_BITRATE", vmpeg_fix_bitrate);
asset.C:	file->tag.set_property("VMPEG_SEQ_CODES", vmpeg_seq_codes);
asset.C:	file->tag.set_property("DIVX_BITRATE", divx_bitrate);
asset.C:	file->tag.set_property("DIVX_RC_PERIOD", divx_rc_period);
asset.C:	file->tag.set_property("DIVX_RC_REACTION_RATIO", divx_rc_reaction_ratio);
asset.C:	file->tag.set_property("DIVX_RC_REACTION_PERIOD", divx_rc_reaction_period);
asset.C:	file->tag.set_property("DIVX_MAX_KEY_INTERVAL", divx_max_key_interval);
asset.C:	file->tag.set_property("DIVX_MAX_QUANTIZER", divx_max_quantizer);
asset.C:	file->tag.set_property("DIVX_MIN_QUANTIZER", divx_min_quantizer);
asset.C:	file->tag.set_property("DIVX_QUANTIZER", divx_quantizer);
asset.C:	file->tag.set_property("DIVX_QUALITY", divx_quality);
asset.C:	file->tag.set_property("DIVX_FIX_BITRATE", divx_fix_bitrate);
asset.C:	file->tag.set_property("DIVX_USE_DEBLOCKING", divx_use_deblocking);
asset.C:	file->tag.set_property("MS_BITRATE", ms_bitrate);
asset.C:	file->tag.set_property("MS_BITRATE_TOLERANCE", ms_bitrate_tolerance);
asset.C:	file->tag.set_property("MS_INTERLACED", ms_interlaced);
asset.C:	file->tag.set_property("MS_QUANTIZATION", ms_quantization);
asset.C:	file->tag.set_property("MS_GOP_SIZE", ms_gop_size);
asset.C:	file->tag.set_property("MS_FIX_BITRATE", ms_fix_bitrate);
asset.C:	file->tag.set_property("PNG_USE_ALPHA", png_use_alpha);
asset.C:	file->append_tag();
asset.C:	file->append_newline();
asset.C:	file->tag.set_title("INDEX");
asset.C:	file->tag.set_property("ZOOM", index_zoom);
asset.C:	file->tag.set_property("BYTES", index_bytes);
asset.C:	file->append_tag();
asset.C:	file->append_newline();
asset.C:			file->tag.set_title("OFFSET");
asset.C:			file->tag.set_property("FLOAT", index_offsets[i]);
asset.C:			file->append_tag();
asset.C:	file->append_newline();
asset.C:	file->tag.set_title("/INDEX");
asset.C:	file->append_tag();
asset.C:	file->append_newline();
asset.C:#define UPDATE_DEFAULT(x, y) defaults->update(construct_param(x, prefix, string), y);
asset.C:#define GET_DEFAULT(x, y) defaults->get(construct_param(x, prefix, string), y);
asset.C:	index_status = asset->index_status;
asset.C:	index_zoom = asset->index_zoom; 	 // zoom factor of index data
asset.C:	index_start = asset->index_start;	 // byte start of index data in the index file
asset.C:	index_bytes = asset->index_bytes;	 // Total bytes in source file for comparison before rebuilding the index
asset.C:	index_end = asset->index_end;
asset.C:	old_index_end = asset->old_index_end;	 // values for index build
asset.C:	if(asset->index_offsets)
asset.C:		index_offsets = new int64_t[asset->channels];
asset.C:		for(i = 0; i < asset->channels; i++)
asset.C:			index_offsets[i] = asset->index_offsets[i];  // offsets of channels in index file in floats
asset.C:	index_buffer = asset->index_buffer;    // pointer
assetedit.C:	this->mwindow = mwindow;
assetedit.C:		this->asset = asset;
assetedit.C:	this->asset = asset;
assetedit.C:		new_asset = new Asset(asset->path);
assetedit.C:		window->create_objects();
assetedit.C:		result = window->run_window();
assetedit.C: 			if(!asset->equivalent(*new_asset, 1, 1))
assetedit.C:				mwindow->gui->lock_window();
assetedit.C:				asset->copy_from(new_asset, 0);
assetedit.C:				mwindow->gui->update(0,
assetedit.C:				if(asset->audio_data)
assetedit.C:						mwindow->preferences->index_directory,
assetedit.C:						asset->path);
assetedit.C:					asset->index_status = INDEX_NOTTESTED;
assetedit.C:					mwindow->mainindexes->add_next_asset(asset);
assetedit.C:					mwindow->mainindexes->start_build();
assetedit.C:				mwindow->gui->unlock_window();
assetedit.C:				mwindow->awindow->gui->lock_window();
assetedit.C:				mwindow->awindow->gui->update_assets();
assetedit.C:				mwindow->awindow->gui->unlock_window();
assetedit.C:				mwindow->restart_brender();
assetedit.C:				mwindow->sync_parameters(CHANGE_ALL);
assetedit.C: 	mwindow->gui->get_abs_cursor_x() - 400 / 2, 
assetedit.C:	mwindow->gui->get_abs_cursor_y() - 500 / 2, 
assetedit.C:	this->mwindow = mwindow;
assetedit.C:	this->asset_edit = asset_edit;
assetedit.C:	this->asset = asset_edit->new_asset;
assetedit.C:	if(asset->format == FILE_PCM)
assetedit.C:		asset->path, 
assetedit.C:	add_subwindow(new BC_Title(x, y, file.formattostr(mwindow->plugindb, asset->format), MEDIUMFONT, YELLOW));
assetedit.C:	sprintf(string, "%lld", fs.get_size(asset->path));
assetedit.C:	int commas = (len - 1) / 3;
assetedit.C:	for(int i = len + commas, j = len, k; j >= 0 && i >= 0; i--, j--)
assetedit.C:		k = (len - j - 1) / 3;
assetedit.C:		if(k * 3 == len - j - 1 && j != len - 1 && string[j] != 0)
assetedit.C:			string[i--] = ',';
assetedit.C:	if(asset->audio_data)
assetedit.C:		if(asset->acodec[0])
assetedit.C:				asset->acodec[0], 
assetedit.C:				asset->acodec[1], 
assetedit.C:				asset->acodec[2], 
assetedit.C:				asset->acodec[3]);
assetedit.C:		sprintf(string, "%d", asset->channels);
assetedit.C:			textbox->create_objects();
assetedit.C:		sprintf(string, "%d", asset->sample_rate);
assetedit.C:			x += textbox->get_w();
assetedit.C:				&asset->bits, 
assetedit.C:			bitspopup->create_objects();
assetedit.C:			add_subwindow(new BC_Title(x, y, File::bitstostr(asset->bits), MEDIUMFONT, YELLOW));
assetedit.C:		sprintf(string, "%d", asset->header);
assetedit.C:				!asset->byte_order, 
assetedit.C:				asset->byte_order, 
assetedit.C:			if(asset->byte_order)
assetedit.C:				add_subwindow(new BC_Title(x, y, _("Lo-Hi"), MEDIUMFONT, YELLOW));
assetedit.C:				add_subwindow(new BC_Title(x, y, _("Hi-Lo"), MEDIUMFONT, YELLOW));
assetedit.C:			add_subwindow(new AssetEditSigned(this, asset->signed_, x, y));
assetedit.C:			if(!asset->signed_ && asset->bits == 8)
assetedit.C:	if(asset->video_data)
assetedit.C:		if(asset->vcodec[0])
assetedit.C:				asset->vcodec[0], 
assetedit.C:				asset->vcodec[1], 
assetedit.C:				asset->vcodec[2], 
assetedit.C:				asset->vcodec[3]);
assetedit.C:		sprintf(string, "%.2f", asset->frame_rate);
assetedit.C:		sprintf(string, "%d", asset->width);
assetedit.C:		sprintf(string, "%d", asset->height);
assetedit.C:	this->fwindow = fwindow;
assetedit.C:	fwindow->asset->channels = atol(get_text());
assetedit.C:	this->fwindow = fwindow;
assetedit.C:	fwindow->asset->sample_rate = atol(get_text());
assetedit.C:	this->fwindow = fwindow;
assetedit.C:	fwindow->asset->frame_rate = atof(get_text());
assetedit.C:	this->fwindow = fwindow;
assetedit.C:	fwindow->asset->header = atol(get_text());
assetedit.C: : BC_Radial(x, y, value, _("Lo-Hi"))
assetedit.C:	this->fwindow = fwindow;
assetedit.C:	fwindow->asset->byte_order = 1;
assetedit.C:	fwindow->hilo->update(0);
assetedit.C: : BC_Radial(x, y, value, _("Hi-Lo"))
assetedit.C:	this->fwindow = fwindow;
assetedit.C:	fwindow->asset->byte_order = 0;
assetedit.C:	fwindow->lohi->update(0);
assetedit.C:	this->fwindow = fwindow;
assetedit.C:	fwindow->asset->signed_ = get_value();
assetedit.C: : BC_TextBox(5, y, 300, 1, fwindow->asset->path) 
assetedit.C:	this->fwindow = fwindow; 
assetedit.C:	strcpy(fwindow->asset->path, get_text());
assetedit.C:	this->fwindow = fwindow; 
assetedit.C: : FormatPopup(fwindow->mwindow->plugindb, 90, y)
assetedit.C:	this->fwindow = fwindow; 
assetedit.C:	fwindow->asset->format = File::strtoformat(fwindow->mwindow->plugindb, get_selection(0, 0)->get_text());
assetpopup.C:	this->mwindow = mwindow;
assetpopup.C:	this->gui = gui;
assetpopup.C:	gui->lock_window();
assetpopup.C:	mwindow->gui->lock_window();
assetpopup.C:	mwindow->cwindow->gui->lock_window();
assetpopup.C:	gui->collect_assets();
assetpopup.C:	mwindow->paste_assets(mwindow->edl->local_session->selectionstart, 
assetpopup.C:		mwindow->edl->tracks->first);
assetpopup.C:	gui->unlock_window();
assetpopup.C:	mwindow->gui->unlock_window();
assetpopup.C:	mwindow->cwindow->gui->unlock_window();
assetpopup.C:	gui->collect_assets();
assetpopup.C:	mwindow->gui->lock_window();
assetpopup.C:	mwindow->asset_to_size();
assetpopup.C:	mwindow->gui->unlock_window();
assetpopup.C:	format->update();
assetpopup.C:	gui->collect_assets();
assetpopup.C:	this->mwindow = mwindow;
assetpopup.C:	this->popup = popup;
assetpopup.C:	if(mwindow->session->drag_assets->total)
assetpopup.C:		if(mwindow->awindow->asset_edit->running() && 
assetpopup.C:			mwindow->awindow->asset_edit->window)
assetpopup.C:			mwindow->awindow->asset_edit->window->raise_window();
assetpopup.C:			mwindow->awindow->asset_edit->window->flush();
assetpopup.C:			mwindow->awindow->asset_edit->edit_asset(
assetpopup.C:				mwindow->session->drag_assets->values[0]);
assetpopup.C:	if(mwindow->session->drag_clips->total)
assetpopup.C:		popup->gui->awindow->clip_edit->edit_clip(
assetpopup.C:			mwindow->session->drag_clips->values[0]);
assetpopup.C:	this->mwindow = mwindow;
assetpopup.C:	this->popup = popup;
assetpopup.C:	mwindow->rebuild_indices();
assetpopup.C:	this->mwindow = mwindow;
assetpopup.C:	this->popup = popup;
assetpopup.C:	mwindow->awindow->gui->sort_assets();
assetpopup.C:	this->mwindow = mwindow;
assetpopup.C:	this->popup = popup;
assetpopup.C:	mwindow->vwindow->gui->lock_window();
assetpopup.C:	if(mwindow->session->drag_assets->total)
assetpopup.C:		mwindow->vwindow->change_source(
assetpopup.C:			mwindow->session->drag_assets->values[0]);
assetpopup.C:	if(mwindow->session->drag_clips->total)
assetpopup.C:		mwindow->vwindow->change_source(
assetpopup.C:			mwindow->session->drag_clips->values[0]);
assetpopup.C:	mwindow->vwindow->gui->unlock_window();
assetpopup.C:	this->mwindow = mwindow;
assetpopup.C:	this->popup = popup;
assetpopup.C:	popup->paste_assets();
assetpopup.C:	this->mwindow = mwindow;
assetpopup.C:	this->popup = popup;
assetpopup.C:	popup->match_size();
assetpopup.C:	this->mwindow = mwindow;
assetpopup.C:	this->popup = popup;
assetpopup.C:	mwindow->remove_assets_from_project(1);
assetpopup.C:	this->mwindow = mwindow;
assetpopup.C:	this->popup = popup;
assetpopup.C:	mwindow->awindow->asset_remove->start();
assetremove.C:				mwindow->gui->get_abs_cursor_x(),
assetremove.C:				mwindow->gui->get_abs_cursor_y(),
assetremove.C:				-1, 
assetremove.C:				-1, 
assetremove.C:	this->mwindow = mwindow;
assetremove.C:	this->mwindow = mwindow;
assetremove.C:	window->create_objects();
assetremove.C:	int result = window->run_window();
assetremove.C:		mwindow->remove_assets_from_disk();
assets.C:	this->edl = edl;
assets.C:		result = file->read_tag();
assets.C:			if(file->tag.title_is("/ASSETS"))
assets.C:			if(file->tag.title_is("ASSET"))
assets.C:				char *path = file->tag.get_property("SRC");
assets.C:	file->tag.set_title("ASSETS");
assets.C:	file->append_tag();
assets.C:	file->append_newline();
assets.C:		current->write(plugindb, 
assets.C:	file->tag.set_title("/ASSETS");
assets.C:	file->append_tag();
assets.C:	file->append_newline();	
assets.C:	file->append_newline();	
assets.C:		new_asset->copy_from(current, 1);
assets.C:		if(current->test_path(asset->path))
assets.C:			current->update_index(asset);
assets.C:		if(current->test_path(asset->path)) 
assets.C:		if(current->test_path(path)) 
assets.C:		if(current->test_path(filename))
assets.C:		current = current->next;
assets.C:		if(!strcmp(current->path, old_filename))
assets.C:			current->update_path(new_filename);
assets.C:		current->dump();
atrack.C:	file->tag.set_property("TYPE", "AUDIO");
atrack.C:	file->append_newline();
atrack.C:	automation->create_objects();
atrack.C:		patch_h += theme->title_h + theme->play_h + theme->fade_h + theme->meter_h + theme->pan_h;
atrack.C:	Track *current = ListItem<Track>::owner->first;
atrack.C:		if(current->data_type == TRACK_AUDIO) i++;
atrack.C:		return Units::round(position * edl->session->sample_rate);
atrack.C:		return Units::to_int64(position * edl->session->sample_rate);
atrack.C:	return position * edl->session->sample_rate;
atrack.C:	return (double)position / edl->session->sample_rate;
atrack.C:	if(labs(sample1 - sample2) <= 1) return 1; else return 0;
atrack.C:	return edits->length();
atrack.C:	view_start = (double)edl->local_session->view_start * edl->session->sample_rate;
atrack.C://	view_units = (double)tracks->view_samples();
atrack.C:	zoom_units = (double)edl->local_session->zoom_sample;
atrack.C:	if(!strcmp(xml->tag.get_title(), "PANAUTOS"))
atrack.C:		current_channel = xml->tag.get_property("CHANNEL", current_channel);
atrack.C://		pan_autos->paste(start, end, total_length, xml, "/PANAUTOS", mwindow->session->autos_follow_edits);
attachmentpoint.C:	this->plugin = plugin;
attachmentpoint.C:	this->renderengine = renderengine;
attachmentpoint.C:	plugin_server = renderengine->scan_plugindb(plugin->title);
attachmentpoint.C://printf("AttachmentPoint::AttachmentPoint %s %p\n", plugin->title, plugin_server);
attachmentpoint.C:	if(plugin_server && plugin->on)
attachmentpoint.C:				if(i == 0 || !plugin_server->multichannel)
attachmentpoint.C:					new_server->set_attachmentpoint(this);
attachmentpoint.C:					plugin_servers.values[i]->open_plugin(0, 
attachmentpoint.C:						renderengine->preferences,
attachmentpoint.C:						renderengine->edl, 
attachmentpoint.C:						-1);
attachmentpoint.C:					plugin_servers.values[i]->init_realtime(
attachmentpoint.C:						renderengine->edl->session->real_time_playback &&
attachmentpoint.C:							renderengine->command->realtime,
attachmentpoint.C:	if(plugin_server && plugin->on && virtual_plugins.total && !duplicate)
attachmentpoint.C:			if(i == 0 || !plugin_server->multichannel)
attachmentpoint.C:				plugin_servers.values[i]->close_plugin();
attachmentpoint.C:	if(plugin_server && plugin->on)
attachmentpoint.C://printf("AttachmentPoint::attach_virtual_plugin %p %d %d %d\n", plugin_server, plugin->on, in_buffer_number, new_total_input_buffers);
attachmentpoint.C:		if(!new_virtual_plugins.values[i]->waiting_real_plugin) result = 1;
attachmentpoint.C:			plugin_server->multichannel) return 1;
attachmentpoint.C:			plugin_server->multichannel) return 1;
attachmentpoint.C:	if(plugin_server && !plugin_server->multichannel) return 1;
attachmentpoint.C://printf("AttachmentPoint::render 1 %p %s\n", plugin_server, plugin_server->title);
attachmentpoint.C:		if(current_buffer == total_input_buffers - 1 ||
attachmentpoint.C:			!plugin_server->multichannel)
attachmentpoint.C://printf("AttachmentPoint::render_gui 1 %p %p\n", renderengine, renderengine->mwindow);
attachmentpoint.C:	if(renderengine && renderengine->mwindow)
attachmentpoint.C:		renderengine->mwindow->render_plugin_gui(data, plugin);
attachmentpoint.C:	if(renderengine && renderengine->mwindow)
attachmentpoint.C:		renderengine->mwindow->render_plugin_gui(data, size, plugin);
attachmentpoint.C:	if(plugin_server) plugin_server->dump();
audio1394.C:		device->in_channels = 2;
audio1394.C:		device->in_bits = 16;
audio1394.C:		bytes_per_sample = device->in_channels * device->in_bits / 8;
audio1394.C:		result = input_thread->open(device->in_config->firewire_port, 
audio1394.C:			device->in_config->firewire_channel, 
audio1394.C:			device->in_channels,
audio1394.C:			device->in_samplerate,
audio1394.C:			device->in_bits);
audio1394.C:		device->out_channels = 2;
audio1394.C:		device->out_bits = 16;
audio1394.C:		bytes_per_sample = device->out_channels * device->out_bits / 8;
audio1394.C:		if(device->driver == AUDIO_DV1394)
audio1394.C:			output_thread->open(device->out_config->dv1394_path,
audio1394.C:				device->out_config->dv1394_port,
audio1394.C:				device->out_config->dv1394_channel,
audio1394.C:				device->out_channels, 
audio1394.C:				device->out_bits, 
audio1394.C:				device->out_samplerate,
audio1394.C:				device->out_config->dv1394_syt);
audio1394.C:			output_thread->open(device->out_config->firewire_path,
audio1394.C:				device->out_config->firewire_port,
audio1394.C:				device->out_config->firewire_channel,
audio1394.C:				device->out_channels, 
audio1394.C:				device->out_bits, 
audio1394.C:				device->out_samplerate,
audio1394.C:				device->out_config->firewire_syt);
audio1394.C:		input_thread->read_audio(buffer, bytes / bytes_per_sample);
audio1394.C:		output_thread->write_samples(buffer, bytes / bytes_per_sample);
audio1394.C:		return output_thread->get_audio_position();
audio1394.C:		output_thread->flush();
audio1394.C:		output_thread->interrupt();
audioalsa.C:	card = -1;
audioalsa.C:		dev = -1;
audioalsa.C:				if(err != -ENOENT)
audioalsa.C:			char *result = devices->append(new char[strlen(string) + 1]);
audioalsa.C:	device->device_buffer = buffer_size / 
audioalsa.C:printf("AudioALSA::set_params 2 %d %d\n", samples,  device->device_buffer);
audioalsa.C:	device->in_channels = device->in_config->alsa_in_channels;
audioalsa.C:	device->in_bits = device->in_config->alsa_in_bits;
audioalsa.C:	translate_name(pcm_name, device->in_config->alsa_in_device);
audioalsa.C:		device->in_config->alsa_in_channels, 
audioalsa.C:		device->in_config->alsa_in_bits,
audioalsa.C:		device->in_samplerate,
audioalsa.C:		device->in_samples);
audioalsa.C:	device->out_channels = device->out_config->alsa_out_channels;
audioalsa.C:	device->out_bits = device->out_config->alsa_out_bits;
audioalsa.C:	translate_name(pcm_name, device->out_config->alsa_out_device);
audioalsa.C:		device->out_config->alsa_out_channels, 
audioalsa.C:		device->out_config->alsa_out_bits,
audioalsa.C:		device->out_samplerate,
audioalsa.C:		device->out_samples);
audioalsa.C:	if(device->r)
audioalsa.C:	if(device->w)
audioalsa.C:	if(device->d)
audioalsa.C:	return -1;
audioalsa.C:		size / (device->in_bits / 8) / device->in_channels);
audioalsa.C:		size / (device->out_bits / 8) / device->out_channels) < 0)
audioalsa.C:	if(device->w) return dsp_out;
audioalsa.C:	if(device->d) return dsp_duplex;
audioalsa.C:	if(device->r) return dsp_in;
audioalsa.C:	if(device->d) return dsp_duplex;
audioconfig.C:	audio_in_driver =             defaults->get("AUDIOINDRIVER", AUDIO_OSS);
audioconfig.C:	afirewire_in_port =           defaults->get("AFIREWIRE_IN_PORT", 0);
audioconfig.C:	afirewire_in_channel =        defaults->get("AFIREWIRE_IN_CHANNEL", 63);
audioconfig.C:	                              defaults->get("OSS_IN_DEVICE", oss_in_device);
audioconfig.C:	oss_in_channels =             defaults->get("OSS_IN_CHANNELS", 2);
audioconfig.C:	oss_in_bits =                 defaults->get("OSS_IN_BITS", 16);
audioconfig.C:	                              defaults->get("ESOUND_IN_SERVER", esound_in_server);
audioconfig.C:	esound_in_port =              defaults->get("ESOUND_IN_PORT", 0);
audioconfig.C:	audio_out_driver =  		  defaults->get("AUDIO_OUT_DRIVER", AUDIO_OSS);
audioconfig.C:	audio_duplex_driver =		  defaults->get("AUDIO_DUPLEX_DRIVER", AUDIO_OSS);
audioconfig.C:	                              defaults->get("OSS_OUT_DEVICE", oss_out_device);
audioconfig.C:	oss_out_channels =  		  defaults->get("OUT_CHANNELS", 2);
audioconfig.C:	oss_out_bits =                defaults->get("OUT_BITS", 16);
audioconfig.C:	                              defaults->get("ESOUND_OUT_SERVER", esound_out_server);
audioconfig.C:	esound_out_port =             defaults->get("ESOUND_OUT_PORT", 0);
audioconfig.C:	audio_duplex_driver =         defaults->get("AUDIO_DUPLEX_DRIVER", AUDIO_OSS);
audioconfig.C:	                              defaults->get("OSS_DUPLEX_DEVICE", oss_duplex_device);
audioconfig.C:	oss_duplex_channels =         defaults->get("DUPLEX_CHANNELS", 2);
audioconfig.C:	oss_duplex_bits =             defaults->get("DUPLEX_BITS", 16);
audioconfig.C:	                              defaults->get("ESOUND_DUPLEX_SERVER", esound_duplex_server);
audioconfig.C:	esound_duplex_port =          defaults->get("ESOUND_DUPLEX_PORT", 0);
audioconfig.C:	defaults->update("AUDIOINDRIVER", audio_in_driver);
audioconfig.C:	defaults->update("AFIREWIRE_IN_PORT", afirewire_in_port);
audioconfig.C:	defaults->update("AFIREWIRE_IN_CHANNEL", afirewire_in_channel);
audioconfig.C:	defaults->update("OSS_IN_DEVICE", oss_in_device);
audioconfig.C:	defaults->update("OSS_IN_CHANNELS", oss_in_channels);
audioconfig.C:	defaults->update("OSS_IN_BITS", oss_in_bits);
audioconfig.C:	defaults->update("ESOUND_IN_SERVER", esound_in_server);
audioconfig.C:	defaults->update("ESOUND_IN_PORT", esound_in_port);
audioconfig.C:	defaults->update("AUDIO_OUT_DRIVER", audio_out_driver);
audioconfig.C:	defaults->update("AUDIO_DUPLEX_DRIVER", audio_duplex_driver);
audioconfig.C:	defaults->update("OSS_OUT_DEVICE", oss_out_device);
audioconfig.C:	defaults->update("OUT_CHANNELS", oss_out_channels);
audioconfig.C:	defaults->update("OUT_BITS", oss_out_bits);
audioconfig.C:	defaults->update("ESOUND_OUT_SERVER", esound_out_server);
audioconfig.C:	defaults->update("ESOUND_OUT_PORT", esound_out_port);
audioconfig.C:	defaults->update("AUDIO_DUPLEX_DRIVER", audio_duplex_driver);
audioconfig.C:	defaults->update("OSS_DUPLEX_DEVICE", oss_duplex_device);
audioconfig.C:	defaults->update("OSS_DUPLEX_CHANNELS", oss_duplex_channels);
audioconfig.C:	defaults->update("OSS_DUPLEX_BITS", oss_duplex_bits);
audioconfig.C:	defaults->update("ESOUND_DUPLEX_SERVER", esound_duplex_server);
audioconfig.C:	defaults->update("ESOUND_DUPLEX_PORT", esound_duplex_port);
audiodevice.C:	this->device = device;
audiodevice.C:	this->out_config = new AudioOutConfig(0, 0, 0);
audiodevice.C:	this->in_config = new AudioInConfig;
audiodevice.C:	this->driver = driver;
audiodevice.C:	*this->in_config = *config;
audiodevice.C://printf("AudioDevice::open_input %s\n", this->in_config->oss_in_device[0]);
audiodevice.C:	create_lowlevel(lowlevel_in, config->driver);
audiodevice.C:	lowlevel_in->open_input();
audiodevice.C:	*this->out_config = *config;
audiodevice.C:	create_lowlevel(lowlevel_out, config->driver);
audiodevice.C:	lowlevel_out->open_output();
audiodevice.C:	*this->out_config = *out_config;
audiodevice.C:		duplex_channels += out_config->oss_out_channels[i];
audiodevice.C:	create_lowlevel(lowlevel_duplex, out_config->driver);
audiodevice.C:	lowlevel_duplex->open_duplex();
audiodevice.C:	if(lowlevel_in) return lowlevel_in->interrupt_crash();
audiodevice.C:	if(lowlevel_in) lowlevel_in->close_all();
audiodevice.C:	if(lowlevel_out) lowlevel_out->close_all();
audiodevice.C:	if(lowlevel_duplex) lowlevel_duplex->close_all();
audiodevice.C:	this->vdevice = vdevice;
audioesound.C:	device->in_channels = 2;
audioesound.C:	device->in_bits = 16;
audioesound.C:	format |= get_channels_flag(device->in_channels);
audioesound.C:	format |= get_bit_flag(device->in_bits);
audioesound.C:	if((esd_in = esd_open_sound(translate_device_string(device->in_config->esound_in_server, device->in_config->esound_in_port))) <= 0)
audioesound.C:	esd_in_fd = esd_record_stream_fallback(format, device->in_samplerate, 
audioesound.C:			    	translate_device_string(device->out_config->esound_out_server, device->out_config->esound_out_port), 
audioesound.C:	device->out_channels = 2;
audioesound.C:	device->out_bits = 16;
audioesound.C:	format |= get_channels_flag(device->out_channels);
audioesound.C:	format |= get_bit_flag(device->out_bits);
audioesound.C:	if((esd_out = esd_open_sound(translate_device_string(device->out_config->esound_out_server, device->out_config->esound_out_port))) <= 0)
audioesound.C:	esd_out_fd = esd_play_stream_fallback(format, device->out_samplerate, 
audioesound.C:			    	translate_device_string(device->out_config->esound_out_server, device->out_config->esound_out_port), 
audioesound.C:	device->device_buffer = esd_get_latency(esd_out);
audioesound.C:	device->device_buffer *= device->out_bits / 8 * device->out_channels;
audioesound.C:	device->duplex_channels = 2;
audioesound.C:	device->duplex_bits = 16;
audioesound.C:	if(device->r || device->d)
audioesound.C:	if(device->w || device->d)
audioesound.C:	return -1;
audioidevice.C:	dc_offset_thread->calibrate_dc_offset(output, dc_offset_text, get_ichannels());
audioidevice.C:	dc_offset_thread->dc_offset[channel] = dc_offset;
audioidevice.C:					else if(-sample > max[i]) max[i] = -sample;
audioidevice.C:sample -= dc_offset_value;        \
audioidevice.C:if(dither_scale) { dither_value = rand() % dither_scale; sample -= dither_value; } \
audioidevice.C:sample -= dc_offset_value;                                    \
audioidevice.C:sample -= dc_offset_value; \
audioidevice.C:sample -= dc_offset_value; \
audioidevice.C:		duplex_lock->lock("AudioDevice::read_buffer");
audioidevice.C:	result = get_lowlevel_in()->read_buffer(input_buffer, samples * frame);
audioidevice.C:		duplex_lock->unlock();
audioidevice.C:		dc_offset_value = dc_offset_thread->dc_offset[i];
audioidevice.C:		if(dc_offset_thread->dc_offset[i] <= 0) 
audioidevice.C:			min_sample[i] = -denominator - dc_offset_thread->dc_offset[i]; 
audioidevice.C:			min_sample[i] = -denominator; 
audioidevice.C:			max_sample[i] = denominator - dc_offset_thread->dc_offset[i]; 
audioidevice.C:				if(dc_offset_thread->getting_dc_offset)
audioidevice.C:					dc_offset_total = &(dc_offset_thread->dc_offset_total[i]);
audioidevice.C:					dc_offset_total = &(dc_offset_thread->dc_offset_total[i]);
audioidevice.C:					if(dc_offset_thread->getting_dc_offset)
audioidevice.C:					dc_offset_total = &(dc_offset_thread->dc_offset_total[i]);
audioidevice.C:					if(dc_offset_thread->getting_dc_offset)
audioidevice.C:					dc_offset_total = &(dc_offset_thread->dc_offset_total[i]);
audioidevice.C:					if(dc_offset_thread->getting_dc_offset)
audioidevice.C:	if(dc_offset_thread->getting_dc_offset) 
audioidevice.C:		dc_offset_thread->dc_offset_count += samples * channels;
audioidevice.C:		if(dc_offset_thread->progress->update(dc_offset_thread->dc_offset_count))
audioidevice.C:			dc_offset_thread->getting_dc_offset = 0;
audioidevice.C:			dc_offset_thread->dc_offset_lock->unlock();
audioidevice.C:		if(dc_offset_thread->dc_offset_count > 256000)
audioidevice.C:				dc_offset_thread->dc_offset[i] = dc_offset_thread->dc_offset_total[i] / dc_offset_thread->dc_offset_count * 2; // don't know why * 2
audioidevice.C:			dc_offset_thread->getting_dc_offset = 0;
audioidevice.C:			dc_offset_thread->dc_offset_lock->unlock();
audioodevice.C:	arm_lock[arm_buffer_num]->lock("AudioDevice::set_last_buffer");
audioodevice.C:	play_lock[arm_buffer_num]->unlock();
audioodevice.C:	if(channels == -1) channels = get_ochannels();
audioodevice.C:	arm_lock[buffer_num]->lock("AudioDevice::arm_buffer");
audioodevice.C:	last_input_channel = channels - 1;
audioodevice.C:						int_sample -= dither_value;
audioodevice.C:				output_advance = device_channels * 2 - 1;
audioodevice.C:						int_sample -= dither_value;
audioodevice.C:				output_advance = (device_channels - 1) * 3;
audioodevice.C:				output_advance = (device_channels - 1) * 4;
audioodevice.C:	play_lock[buffer_num]->unlock();
audioodevice.C:		arm_lock[i]->reset();
audioodevice.C:		play_lock[i]->reset(); 
audioodevice.C:		get_lowlevel_out()->interrupt_playback();
audioodevice.C:		play_lock[i]->unlock();  
audioodevice.C:		arm_lock[i]->unlock();
audioodevice.C:	startup_lock->lock("AudioDevice::wait_for_startup");
audioodevice.C:			hardware_result = get_lowlevel_out()->device_position();
audioodevice.C:			timer_lock->lock("AudioDevice::current_position");
audioodevice.C:			software_result = total_samples - last_buffer_size - 
audioodevice.C:			timer_lock->unlock();
audioodevice.C:	startup_lock->unlock();
audioodevice.C:		play_lock[thread_buffer_num]->lock("AudioDevice::run 1");
audioodevice.C:					duplex_lock->lock("AudioDevice::run 2");
audioodevice.C:					duplex_lock->unlock();
audioodevice.C:			timer_lock->lock("AudioDevice::run 3");
audioodevice.C:			timer_lock->unlock();
audioodevice.C:			thread_result = get_lowlevel_out()->write_buffer(buffer[thread_buffer_num], buffer_size[thread_buffer_num]);
audioodevice.C:			arm_lock[thread_buffer_num]->unlock();
audioodevice.C:			get_lowlevel_out()->flush_device();
audiooss.C:	this->device = device;
audiooss.C:	input_lock->unlock();
audiooss.C:		input_lock->lock("OSSThread::run 1");
audiooss.C:			read_lock->unlock();
audiooss.C:			write_lock->unlock();
audiooss.C:		output_lock->unlock();
audiooss.C:	output_lock->lock("OSSThread::write_data");
audiooss.C:	this->data = data;
audiooss.C:	this->bytes = bytes;
audiooss.C:	this->fd = fd;
audiooss.C:	input_lock->unlock();
audiooss.C:	output_lock->lock("OSSThread::read_data");
audiooss.C:	this->data = data;
audiooss.C:	this->bytes = bytes;
audiooss.C:	this->fd = fd;
audiooss.C:	input_lock->unlock();
audiooss.C:	read_lock->lock("OSSThread::wait_read");
audiooss.C:	write_lock->lock("OSSThread::wait_write");
audiooss.C:	device->in_channels = 0;
audiooss.C:		if(device->in_config->oss_enable[i])
audiooss.C:			device->in_channels += device->in_config->oss_in_channels[i];
audiooss.C:	device->in_bits = device->in_config->oss_in_bits;
audiooss.C:	if(device->in_bits == 24) device->in_bits = 32;
audiooss.C:		if(device->in_config->oss_enable[i])
audiooss.C:			dsp_in[i] = open(device->in_config->oss_in_device[i], O_RDONLY/* | O_NDELAY*/);
audiooss.C:				device->in_config->oss_in_device[i], 
audiooss.C:			int format = get_fmt(device->in_config->oss_in_bits);
audiooss.C:			int buffer_info = sizetofrag(device->in_samples, 
audiooss.C:				device->in_config->oss_in_channels[i], 
audiooss.C:				device->in_config->oss_in_bits);
audiooss.C://printf("AudioOSS::open_input %d %d %d\n", device->in_samples, device->in_config->oss_in_channels[i], device->in_config->oss_in_bits);
audiooss.C:			if(device->driver == AUDIO_OSS_ENVY24) buffer_info = 0x7fff000f;
audiooss.C:			if(ioctl(dsp_in[i], SNDCTL_DSP_CHANNELS, &device->in_config->oss_in_channels[i]) < 0) printf("SNDCTL_DSP_CHANNELS failed\n");
audiooss.C:			if(ioctl(dsp_in[i], SNDCTL_DSP_SPEED, &device->in_samplerate) < 0) printf("SNDCTL_DSP_SPEED failed\n");
audiooss.C:			thread[i]->start();
audiooss.C:	device->out_channels = 0;
audiooss.C:		if(device->out_config->oss_enable[i])
audiooss.C:			device->out_channels += device->out_config->oss_out_channels[i];
audiooss.C:	device->out_bits = device->out_config->oss_out_bits;
audiooss.C:	if(device->out_bits == 24) device->out_bits = 32;
audiooss.C:		if(device->out_config->oss_enable[i])
audiooss.C:				open(device->out_config->oss_out_device[i], 
audiooss.C:			int format = get_fmt(device->out_config->oss_out_bits);
audiooss.C:			int buffer_info = sizetofrag(device->out_samples, 
audiooss.C:				device->out_config->oss_out_channels[i], 
audiooss.C:				device->out_config->oss_out_bits);
audiooss.C:			if(device->driver == AUDIO_OSS_ENVY24) buffer_info = 0x7fff000f;
audiooss.C:			if(ioctl(dsp_out[i], SNDCTL_DSP_CHANNELS, &device->out_config->oss_out_channels[i]) < 0) printf("SNDCTL_DSP_CHANNELS 2 failed\n");
audiooss.C:			if(ioctl(dsp_out[i], SNDCTL_DSP_SPEED, &device->out_samplerate) < 0) printf("SNDCTL_DSP_SPEED 2 failed\n");
audiooss.C:			device->device_buffer = playinfo.bytes;
audiooss.C:			thread[i]->start();
audiooss.C:	device->duplex_channels = 0;
audiooss.C:		if(device->out_config->oss_enable[i])
audiooss.C:			device->duplex_channels += device->out_config->oss_out_channels[i];
audiooss.C:	device->duplex_bits = device->out_config->oss_out_bits;
audiooss.C:	if(device->duplex_bits == 24) device->duplex_bits = 32;
audiooss.C:		if(device->out_config->oss_enable[i])
audiooss.C:			dsp_duplex[i] = open(device->out_config->oss_out_device[i], O_RDWR/* | O_NDELAY*/);
audiooss.C:			int format = get_fmt(device->out_config->oss_out_bits);
audiooss.C:			int buffer_info = sizetofrag(device->duplex_samples, 
audiooss.C:				device->out_config->oss_out_channels[i], 
audiooss.C:				device->out_config->oss_out_bits);
audiooss.C:			if(device->driver == AUDIO_OSS_ENVY24) buffer_info = 0x7fff000f;
audiooss.C:			if(ioctl(dsp_duplex[i], SNDCTL_DSP_SETDUPLEX, 1) == -1) printf("SNDCTL_DSP_SETDUPLEX failed\n");
audiooss.C:			if(ioctl(dsp_duplex[i], SNDCTL_DSP_CHANNELS, &device->out_config->oss_out_channels[i]) < 0) printf("SNDCTL_DSP_CHANNELS failed\n");
audiooss.C:			if(ioctl(dsp_duplex[i], SNDCTL_DSP_SPEED, &device->duplex_samplerate) < 0) printf("SNDCTL_DSP_SPEED failed\n");
audiooss.C:			device->device_buffer = playinfo.bytes;
audiooss.C:			thread[i]->start();
audiooss.C://printf("AudioOSS::device_position %d %d %d\n", info.bytes, device->get_obits(), device->get_ochannels());
audiooss.C:			(device->get_obits() / 8) / 
audiooss.C:			device->get_ochannels();
audiooss.C:			thread[i]->cancel();
audiooss.C:			thread[i]->write_lock->unlock();
audiooss.C:	int sample_size = device->get_ibits() / 8;
audiooss.C:	int out_frame_size = device->get_ichannels() * sample_size;
audiooss.C:			int in_frame_size = device->in_config->oss_in_channels[i] * sample_size;
audiooss.C:			thread[i]->read_data(get_input(i), data[i], samples * in_frame_size);
audiooss.C://printf("AudioOSS::read_buffer 1 %d\n", device->get_ibits());
audiooss.C:			thread[i]->wait_read();
audiooss.C:				in_channel < device->in_config->oss_in_channels[i]; 
audiooss.C:				int in_frame_size = device->in_config->oss_in_channels[i] * sample_size;
audiooss.C:	int sample_size = device->get_obits() / 8;
audiooss.C:	int in_frame_size = device->get_ochannels() * sample_size;
audiooss.C:			int out_frame_size = device->out_config->oss_out_channels[i] * sample_size;
audiooss.C:				out_channel < device->out_config->oss_out_channels[i];
audiooss.C:			thread[i]->write_data(get_output(i), data[i], samples * out_frame_size);
audiooss.C:			thread[i]->wait_write();
audiooss.C:	if(device->w) return dsp_out[number];
audiooss.C:	else if(device->d) return dsp_duplex[number];
audiooss.C:	if(device->r) return dsp_in[number];
audiooss.C:	else if(device->d) return dsp_duplex[number];
auto.C:	this->edl = 0;
auto.C:	this->autos = 0;
auto.C:	this->edl = edl;
auto.C:	this->autos = autos;
auto.C:	this->position = that->position;
autoconf.C:	fade = defaults->get("SHOW_FADE", 0);
autoconf.C:	pan = defaults->get("SHOW_PAN", 1);
autoconf.C:	mute = defaults->get("SHOW_MUTE", 0);
autoconf.C:	transitions = defaults->get("SHOW_TRANSITIONS", 1);
autoconf.C:	plugins = defaults->get("SHOW_PLUGINS", 1);
autoconf.C:	camera = defaults->get("SHOW_CAMERA", 1);
autoconf.C:	projector = defaults->get("SHOW_PROJECTOR", 1);
autoconf.C:	mode = defaults->get("SHOW_MODE", 1);
autoconf.C:	mask = defaults->get("SHOW_MASK", 0);
autoconf.C:	czoom = defaults->get("SHOW_CZOOM", 0);
autoconf.C:	pzoom = defaults->get("SHOW_PZOOM", 0);
autoconf.C:	fade = file->tag.get_property("SHOW_FADE", 0);
autoconf.C:	pan = file->tag.get_property("SHOW_PAN", 0);
autoconf.C:	mute = file->tag.get_property("SHOW_MUTE", 0);
autoconf.C:	transitions = file->tag.get_property("SHOW_TRANSITIONS", 1);
autoconf.C:	plugins = file->tag.get_property("SHOW_PLUGINS", 1);
autoconf.C:	camera = file->tag.get_property("SHOW_CAMERA", 1);
autoconf.C:	projector = file->tag.get_property("SHOW_PROJECTOR", 1);
autoconf.C:	mode = file->tag.get_property("SHOW_MODE", 1);
autoconf.C:	mask = file->tag.get_property("SHOW_MASK", 0);
autoconf.C:	czoom = file->tag.get_property("SHOW_CZOOM", 0);
autoconf.C:	pzoom = file->tag.get_property("SHOW_PZOOM", 0);
autoconf.C:	defaults->update("SHOW_FADE", fade);
autoconf.C:	defaults->update("SHOW_PAN", pan);
autoconf.C:	defaults->update("SHOW_MUTE", mute);
autoconf.C:	defaults->update("SHOW_TRANSITIONS", transitions);
autoconf.C:	defaults->update("SHOW_PLUGINS", plugins);
autoconf.C:	defaults->update("SHOW_CAMERA", camera);
autoconf.C:	defaults->update("SHOW_PROJECTOR", projector);
autoconf.C:	defaults->update("SHOW_MODE", mode);
autoconf.C:	defaults->update("SHOW_MASK", mask);
autoconf.C:	defaults->update("SHOW_CZOOM", czoom);
autoconf.C:	defaults->update("SHOW_PZOOM", pzoom);
autoconf.C:	file->tag.set_property("SHOW_FADE", fade);
autoconf.C:	file->tag.set_property("SHOW_PAN", pan);
autoconf.C:	file->tag.set_property("SHOW_MUTE", mute);
autoconf.C:	file->tag.set_property("SHOW_TRANSITIONS", transitions);
autoconf.C:	file->tag.set_property("SHOW_PLUGINS", plugins);
autoconf.C:	file->tag.set_property("SHOW_CAMERA", camera);
autoconf.C:	file->tag.set_property("SHOW_PROJECTOR", projector);
autoconf.C:	file->tag.set_property("SHOW_MODE", mode);
autoconf.C:	file->tag.set_property("SHOW_MASK", mask);
autoconf.C:	file->tag.set_property("SHOW_CZOOM", czoom);
autoconf.C:	file->tag.set_property("SHOW_PZOOM", pzoom);
automation.C:	this->edl = edl;
automation.C:	this->track = track;
automation.C:	mute_autos->create_objects();
automation.C:	((IntAuto*)mute_autos->default_auto)->value = 0;
automation.C:	mute_autos->equivalent_output(automation->mute_autos, 0, result);
automation.C:	if(camera_autos) camera_autos->equivalent_output(automation->camera_autos, 0, result);
automation.C:	if(projector_autos) projector_autos->equivalent_output(automation->projector_autos, 0, result);
automation.C:	if(fade_autos) fade_autos->equivalent_output(automation->fade_autos, 0, result);
automation.C:	if(pan_autos) pan_autos->equivalent_output(automation->pan_autos, 0, result);
automation.C:	if(mode_autos) mode_autos->equivalent_output(automation->mode_autos, 0, result);
automation.C:	if(mask_autos) mask_autos->equivalent_output(automation->mask_autos, 0, result);
automation.C:	if(czoom_autos) czoom_autos->equivalent_output(automation->czoom_autos, 0, result);
automation.C:	if(pzoom_autos) pzoom_autos->equivalent_output(automation->pzoom_autos, 0, result);
automation.C:	mute_autos->copy_from(automation->mute_autos);
automation.C:	if(camera_autos) camera_autos->copy_from(automation->camera_autos);
automation.C:	if(projector_autos) projector_autos->copy_from(automation->projector_autos);
automation.C:	if(fade_autos) fade_autos->copy_from(automation->fade_autos);
automation.C:	if(pan_autos) pan_autos->copy_from(automation->pan_autos);
automation.C:	if(mode_autos) mode_autos->copy_from(automation->mode_autos);
automation.C:	if(mask_autos) mask_autos->copy_from(automation->mask_autos);
automation.C:	if(czoom_autos) czoom_autos->copy_from(automation->czoom_autos);
automation.C:	if(pzoom_autos) pzoom_autos->copy_from(automation->pzoom_autos);
automation.C:	if(file->tag.title_is("MUTEAUTOS") && mute_autos)
automation.C:		mute_autos->load(file);
automation.C:	if(file->tag.title_is("FADEAUTOS") && fade_autos)
automation.C:		fade_autos->load(file);
automation.C:	if(file->tag.title_is("PANAUTOS") && pan_autos)
automation.C:		pan_autos->load(file);
automation.C:	if(file->tag.title_is("CAMERAAUTOS") && camera_autos)
automation.C:		camera_autos->load(file);
automation.C:	if(file->tag.title_is("PROJECTORAUTOS") && projector_autos)
automation.C:		projector_autos->load(file);
automation.C:	if(file->tag.title_is("MODEAUTOS") && mode_autos)
automation.C:		mode_autos->load(file);
automation.C:	if(file->tag.title_is("MASKAUTOS") && mask_autos)
automation.C:		mask_autos->load(file);
automation.C:	if(file->tag.title_is("CZOOMAUTOS") && czoom_autos)
automation.C:		czoom_autos->load(file);
automation.C:	if(file->tag.title_is("PZOOMAUTOS") && pzoom_autos)
automation.C:		pzoom_autos->load(file);
automation.C:	if(!autoconf) autoconf = edl->session->auto_conf;
automation.C:	if(file->tag.title_is("MUTEAUTOS") && mute_autos && autoconf->mute)
automation.C:		mute_autos->paste(start, length, scale, file, default_only);
automation.C:	if(file->tag.title_is("FADEAUTOS") && fade_autos && autoconf->fade)
automation.C:		fade_autos->paste(start, length, scale, file, default_only);
automation.C:	if(file->tag.title_is("PANAUTOS") && pan_autos && autoconf->pan)
automation.C:		pan_autos->paste(start, length, scale, file, default_only);
automation.C:	if(file->tag.title_is("CAMERAAUTOS") && camera_autos && autoconf->camera)
automation.C:		camera_autos->paste(start, length, scale, file, default_only);
automation.C:	if(file->tag.title_is("PROJECTORAUTOS") && projector_autos && autoconf->projector)
automation.C:		projector_autos->paste(start, length, scale, file, default_only);
automation.C:	if(file->tag.title_is("MODEAUTOS") && mode_autos && autoconf->mode)
automation.C:		mode_autos->paste(start, length, scale, file, default_only);
automation.C:	if(file->tag.title_is("MASKAUTOS") && mask_autos && autoconf->mask)
automation.C:		mask_autos->paste(start, length, scale, file, default_only);
automation.C:	if(file->tag.title_is("CZOOMAUTOS") && czoom_autos && autoconf->czoom)
automation.C:		czoom_autos->paste(start, length, scale, file, default_only);
automation.C:	if(file->tag.title_is("PZOOMAUTOS") && pzoom_autos && autoconf->pzoom)
automation.C:		pzoom_autos->paste(start, length, scale, file, default_only);
automation.C:	if(mute_autos /* && mute_autos->total() */)
automation.C:		file->tag.set_title("MUTEAUTOS");
automation.C:		file->append_tag();
automation.C:		file->append_newline();
automation.C:		mute_autos->copy(start, 
automation.C:		file->tag.set_title("/MUTEAUTOS");
automation.C:		file->append_tag();
automation.C:		file->append_newline();
automation.C:	if(fade_autos /* && fade_autos->total() */)
automation.C:		file->tag.set_title("FADEAUTOS");
automation.C:		file->append_tag();
automation.C:		file->append_newline();
automation.C:		fade_autos->copy(start, 
automation.C:		file->tag.set_title("/FADEAUTOS");
automation.C:		file->append_tag();
automation.C:		file->append_newline();
automation.C:		file->tag.set_title("CAMERAAUTOS");
automation.C:		file->append_tag();
automation.C:		file->append_newline();
automation.C:		camera_autos->copy(start, 
automation.C:		file->tag.set_title("/CAMERAAUTOS");
automation.C:		file->append_tag();
automation.C:		file->append_newline();
automation.C:		file->tag.set_title("PROJECTORAUTOS");
automation.C:		file->append_tag();
automation.C:		file->append_newline();
automation.C:		projector_autos->copy(start, 
automation.C:		file->tag.set_title("/PROJECTORAUTOS");
automation.C:		file->append_tag();
automation.C:		file->append_newline();
automation.C:		file->tag.set_title("PANAUTOS");
automation.C:		file->append_tag();
automation.C:		file->append_newline();
automation.C:		pan_autos->copy(start, 
automation.C:		file->append_newline();
automation.C:		file->tag.set_title("/PANAUTOS");
automation.C:		file->append_tag();
automation.C:		file->append_newline();
automation.C:		file->tag.set_title("MODEAUTOS");
automation.C:		file->append_tag();
automation.C:		file->append_newline();
automation.C:		mode_autos->copy(start, 
automation.C:		file->tag.set_title("/MODEAUTOS");
automation.C:		file->append_tag();
automation.C:		file->append_newline();
automation.C:		file->tag.set_title("MASKAUTOS");
automation.C:		file->append_tag();
automation.C:		file->append_newline();
automation.C:		mask_autos->copy(start, 
automation.C:		file->tag.set_title("/MASKAUTOS");
automation.C:		file->append_tag();
automation.C:		file->append_newline();
automation.C:		file->tag.set_title("CZOOMAUTOS");
automation.C:		file->append_tag();
automation.C:		file->append_newline();
automation.C:		czoom_autos->copy(start, 
automation.C:		file->tag.set_title("/CZOOMAUTOS");
automation.C:		file->append_tag();
automation.C:		file->append_newline();
automation.C:		file->tag.set_title("PZOOMAUTOS");
automation.C:		file->append_tag();
automation.C:		file->append_newline();
automation.C:		pzoom_autos->copy(start, 
automation.C:		file->tag.set_title("/PZOOMAUTOS");
automation.C:		file->append_tag();
automation.C:		file->append_newline();
automation.C:		temp_autoconf->set_all();
automation.C:	if(autoconf->mute)
automation.C:		mute_autos->clear(start, end, shift_autos);
automation.C:	if(autoconf->fade)
automation.C:		fade_autos->clear(start, end, shift_autos);
automation.C:	if(camera_autos && autoconf->camera)
automation.C:		camera_autos->clear(start, end, shift_autos);
automation.C:	if(projector_autos && autoconf->projector)
automation.C:		projector_autos->clear(start, end, shift_autos);
automation.C:	if(pan_autos && autoconf->pan)
automation.C:		pan_autos->clear(start, end, shift_autos);
automation.C:	if(mode_autos && autoconf->mode)
automation.C:		mode_autos->clear(start, end, shift_autos);
automation.C:	if(mask_autos && autoconf->mask)
automation.C:		mask_autos->clear(start, end, shift_autos);
automation.C:	if(czoom_autos && autoconf->czoom)
automation.C:		czoom_autos->clear(start, end, shift_autos);
automation.C:	if(pzoom_autos && autoconf->pzoom)
automation.C:		pzoom_autos->clear(start, end, shift_autos);
automation.C:	mute_autos->paste_silence(start, end);
automation.C:	fade_autos->paste_silence(start, end);
automation.C:		camera_autos->paste_silence(start, end);
automation.C:		projector_autos->paste_silence(start, end);
automation.C:		pan_autos->paste_silence(start, end);
automation.C:		mode_autos->paste_silence(start, end);
automation.C:		mask_autos->paste_silence(start, end);
automation.C:		czoom_autos->paste_silence(start, end);
automation.C:		pzoom_autos->paste_silence(start, end);
automation.C:	mute_autos->insert_track(automation->mute_autos, 
automation.C:		camera_autos->insert_track(automation->camera_autos, 
automation.C:	if(projector_autos) projector_autos->insert_track(automation->projector_autos, 
automation.C:	if(fade_autos) fade_autos->insert_track(automation->fade_autos, 
automation.C:	if(pan_autos) pan_autos->insert_track(automation->pan_autos, 
automation.C:	if(mode_autos) mode_autos->insert_track(automation->mode_autos, 
automation.C:	if(mask_autos) mask_autos->insert_track(automation->mask_autos, 
automation.C:	if(czoom_autos) czoom_autos->insert_track(automation->czoom_autos, 
automation.C:	if(pzoom_autos) pzoom_autos->insert_track(automation->pzoom_autos, 
automation.C:	mute_autos->resample(old_rate, new_rate);
automation.C:	if(camera_autos) camera_autos->resample(old_rate, new_rate);
automation.C:	if(projector_autos) projector_autos->resample(old_rate, new_rate);
automation.C:	if(fade_autos) fade_autos->resample(old_rate, new_rate);
automation.C:	if(pan_autos) pan_autos->resample(old_rate, new_rate);
automation.C:	if(mode_autos) mode_autos->resample(old_rate, new_rate);
automation.C:	if(mask_autos) mask_autos->resample(old_rate, new_rate);
automation.C:	if(czoom_autos) czoom_autos->resample(old_rate, new_rate);
automation.C:	if(pzoom_autos) pzoom_autos->resample(old_rate, new_rate);
automation.C:	if(mute_autos) length = mute_autos->get_length();
automation.C:	if(camera_autos) length = camera_autos->get_length();
automation.C:	if(projector_autos) length = projector_autos->get_length();
automation.C:	if(fade_autos) length = fade_autos->get_length();
automation.C:	if(pan_autos) length = pan_autos->get_length();
automation.C:	if(mode_autos) length = mode_autos->get_length();
automation.C:	if(mask_autos) length = mask_autos->get_length();
automation.C:	if(czoom_autos) length = czoom_autos->get_length();
automation.C:	if(pzoom_autos) length = pzoom_autos->get_length();
automation.C:	mute_autos->dump();
automation.C:		fade_autos->dump();
automation.C:		pan_autos->dump();
automation.C:		camera_autos->dump();
automation.C:		projector_autos->dump();
automation.C:		mode_autos->dump();
automation.C:		mask_autos->dump();
automation.C:		czoom_autos->dump();
automation.C:		pzoom_autos->dump();
autos.C:	this->edl = edl;
autos.C:	this->track = track;
autos.C:	default_auto->is_default = 1;
autos.C:		current->position = (int64_t)((double)current->position * 
autos.C:		(!total() && !(*default_auto == *autos->default_auto))
autos.C:		for(Auto *current = first, *that_current = autos->first; 
autos.C:			that_current = that_current->next)
autos.C:				int64_t position1 = (autos->last ? autos->last->position : startproject);
autos.C:				int64_t position2 = current->position;
autos.C:				int64_t position1 = (last ? last->position : startproject);
autos.C:				int64_t position2 = that_current->position;
autos.C:				current->position != that_current->position)
autos.C:				int64_t position1 = (current->previous ? 
autos.C:					current->previous->position : 
autos.C:				int64_t position2 = (that_current->previous ? 
autos.C:					that_current->previous->position : 
autos.C:	Auto *current = autos->first, *this_current = first;
autos.C:	default_auto->copy_from(autos->default_auto);
autos.C:	if(autos->first && !autos->last)
autos.C:	for(current = autos->first; current; current = NEXT)
autos.C:		this_current->copy_from(current);
autos.C:		this_current = this_current->next;
autos.C:		Auto *next_current = this_current->next;
autos.C:	if(replace_default) default_auto->copy_from(automation->default_auto);
autos.C:	for(Auto *current = automation->first; current; current = NEXT)
autos.C:		Auto *new_auto = insert_auto(start_unit + current->position);
autos.C:		new_auto->copy_from(current);
autos.C:		new_auto->position = current->position + start_unit;
autos.C:			while(current && current->position < position) current = NEXT;
autos.C:			while(current && current->position > position) current = PREVIOUS;
autos.C:				current && current->position > position; 
autos.C:			while(current && current->position > position) current = PREVIOUS;
autos.C:			while(current && current->position < position) current = NEXT;
autos.C:				current && current->position < position; 
autos.C:	double position_double = edl->local_session->selectionstart;
autos.C:	position_double = edl->align_to_frame(position_double, 0);
autos.C:	int64_t position = track->to_units(position_double, 0);
autos.C:	if(edl->session->auto_keyframes)
autos.C:		unit_position = edl->align_to_frame(unit_position, 0);
autos.C:		unit_position = track->to_units(unit_position, 0);
autos.C:			if(edl->equivalent(current->position, unit_position))
autos.C:		position = edl->local_session->selectionstart;
autos.C:	position = edl->align_to_frame(position, 0);
autos.C:	if(edl->session->auto_keyframes)
autos.C:		result = insert_auto(track->to_units(position, 0));
autos.C:		result = get_prev_auto(track->to_units(position, 0), 
autos.C:			while(current && current->position > position) current = PREVIOUS;
autos.C:			while(current && current->position < position) current = NEXT;
autos.C:				current && current->position <= position;
autos.C:			while(current && current->position < position) current = NEXT;
autos.C:			while(current && current->position > position) current = PREVIOUS;
autos.C:				current && current->position > position;
autos.C:		current && !edl->equivalent(current->position, position); 
autos.C:			current && current->position > position; 
autos.C:			result->copy_from(current);
autos.C:			if(current) result->copy_from(current);
autos.C:		result->position = position;
autos.C:	for( ; current && current->position < start; current = NEXT)
autos.C:	length = end - start;
autos.C:		current->position += length;
autos.C:		result = file->read_tag();
autos.C:			if(strstr(file->tag.get_title(), "AUTOS") && 
autos.C:				file->tag.get_title()[0] == '/')
autos.C:			if(!strcmp(file->tag.get_title(), "AUTO"))
autos.C:						(double)file->tag.get_property("POSITION", 0) *
autos.C:					current->load(file);
autos.C:		default_auto->copy(0, 0, file, default_only);
autos.C:			current && current->position <= end; 
autos.C:			if(current->position >= start && current->position <= end)
autos.C:				current->copy(start, end, file, default_only);
autos.C:		default_auto->copy(0, 0, file, default_only);
autos.C:				if(done && current->position <= PREVIOUS->position)
autos.C:	if((keyframe->next && keyframe->next->position <= keyframe->position) ||
autos.C:		(keyframe->previous && keyframe->previous->position >= keyframe->position))
autos.C:	length = end - start;
autos.C:		((end != start && current->position < end) ||
autos.C:		(end == start && current->position <= end)))
autos.C:		current->position -= length;
autos.C:	if(current->position == position) remove(current);
autos.C:		result = file->read_tag();
autos.C:			if(strstr(file->tag.get_title(), "AUTOS") && file->tag.get_title()[0] == '/')
autos.C:			if(!strcmp(file->tag.get_title(), "AUTO"))
autos.C:					default_auto->load(file);
autos.C:					default_auto->position = 0;
autos.C:					current->position = file->tag.get_property("POSITION", (int64_t)0);
autos.C:					current->load(file);
autos.C://		if(current->position >= start && current->position <= end)
autos.C:			current->position = (int64_t)((current->position - start) * rate_scale + start + 0.5);
autos.C:		current && current->position < position; 
autos.C:	for(current = last; current && current->position >= position; current = PREVIOUS)
autos.C:	for(current = first; current && current->position <= position; current = NEXT)
autos.C:	while(*before && (*before)->next && (*before)->next->position <= start)
autos.C:		*before = (*before)->next;
autos.C:	while(*after && (*after)->previous && (*after)->previous->position >= end)
autos.C:		*after = (*after)->previous;
autos.C:	while(*before && (*before)->position > start) *before = (*before)->previous;
autos.C:	while(*after && (*after)->position < end) *after = (*after)->next;
autos.C:	input_start = reverse ? input_position - buffer_len : input_position;
autos.C://		slope_value = (*current_auto)->value;
autos.C://		slope_value = (*current_auto)->value;
autos.C:		slope_start = (*current_auto)->position;
autos.C:		slope_position = reverse ? slope_start - input_end : input_start - slope_start;
autos.C:		(*current_auto) = reverse ? (*current_auto)->previous : (*current_auto)->next;
autos.C:		slope_end = reverse ? slope_start - (*current_auto)->position : (*current_auto)->position - slope_start;
autos.C://			slope = ((*current_auto)->value - slope_value) / slope_end;
autos.C:		slope_end = buffer_len - buffer_position;
autos.C:		slope_start = (*current_auto)->position;
autos.C://		slope_value = (*current_auto)->value;
autos.C:		(*current_auto) = reverse ? (*current_auto)->previous : (*current_auto)->next;
autos.C:		return last->position + 1;
awindow.C:	this->mwindow = mwindow;
awindow.C:	gui->create_objects();
awindow.C:	gui->update_assets();
awindow.C:	gui->run_window();
awindowgui.C:	this->mwindow = mwindow;
awindowgui.C:	this->gui = gui;
awindowgui.C:	this->asset = asset;
awindowgui.C:	this->id = asset->id;
awindowgui.C:	this->mwindow = mwindow;
awindowgui.C:	this->gui = gui;
awindowgui.C:	this->edl = edl;
awindowgui.C:	this->id = edl->id;
awindowgui.C: : BC_ListBoxItem(folder, gui->folder_icon)
awindowgui.C:	this->mwindow = mwindow;
awindowgui.C:	this->gui = gui;
awindowgui.C:	this->mwindow = mwindow;
awindowgui.C:	this->gui = gui;
awindowgui.C:	this->plugin = plugin;
awindowgui.C:		if(icon != gui->file_icon &&
awindowgui.C:			icon != gui->audio_icon &&
awindowgui.C:			icon != gui->folder_icon &&
awindowgui.C:			icon != gui->clip_icon &&
awindowgui.C:			icon != gui->video_icon) delete icon;
awindowgui.C:		fs.extract_name(name, asset->path);
awindowgui.C:		if(asset->video_data)
awindowgui.C:			if(mwindow->preferences->use_thumbnails)
awindowgui.C:				File *file = mwindow->video_cache->check_out(asset);
awindowgui.C:					pixmap_w = pixmap_h * asset->width / asset->height;
awindowgui.C:					file->set_layer(0);
awindowgui.C:					file->set_video_position(0, mwindow->edl->session->frame_rate);
awindowgui.C:					frame = file->read_frame(BC_RGB888);
awindowgui.C:						icon->draw_vframe(frame,
awindowgui.C:					mwindow->video_cache->check_in(asset);
awindowgui.C:					icon = gui->video_icon;
awindowgui.C:				icon = gui->video_icon;
awindowgui.C:		if(asset->audio_data)
awindowgui.C:			icon = gui->audio_icon;
awindowgui.C://printf("AssetPicon::create_objects 4 %s\n", edl->local_session->clip_title);
awindowgui.C:		strcpy(name, edl->local_session->clip_title);
awindowgui.C:		set_icon(gui->clip_icon);
awindowgui.C:		strcpy(name, plugin->title);
awindowgui.C:		if(plugin->picon)
awindowgui.C:			if(plugin->picon->get_color_model() == BC_RGB888)
awindowgui.C:					plugin->picon->get_w(), 
awindowgui.C:					plugin->picon->get_h());
awindowgui.C:				icon->draw_vframe(plugin->picon,
awindowgui.C:					plugin->picon->get_w(), 
awindowgui.C:					plugin->picon->get_h(),
awindowgui.C:					plugin->picon, 
awindowgui.C:			icon = gui->file_icon;
awindowgui.C: 	mwindow->session->awindow_x, 
awindowgui.C:    mwindow->session->awindow_y, 
awindowgui.C:    mwindow->session->awindow_w, 
awindowgui.C:    mwindow->session->awindow_h,
awindowgui.C:// mwindow->session->awindow_x, 
awindowgui.C:// mwindow->session->awindow_y, 
awindowgui.C:// mwindow->session->awindow_w, 
awindowgui.C:// mwindow->session->awindow_h);
awindowgui.C:	this->mwindow = mwindow;
awindowgui.C:	this->awindow = awindow;
awindowgui.C:	set_icon(mwindow->theme->awindow_icon);
awindowgui.C:		BC_WindowBase::get_resources()->type_to_icon[ICON_UNKNOWN],
awindowgui.C:		BC_WindowBase::get_resources()->type_to_icon[ICON_FOLDER],
awindowgui.C:		BC_WindowBase::get_resources()->type_to_icon[ICON_SOUND],
awindowgui.C:		BC_WindowBase::get_resources()->type_to_icon[ICON_FILM],
awindowgui.C:		mwindow->theme->clip_icon,
awindowgui.C:	picon->persistent = 1;
awindowgui.C:	picon->persistent = 1;
awindowgui.C:	picon->persistent = 1;
awindowgui.C:	picon->persistent = 1;
awindowgui.C:	mwindow->theme->get_awindow_sizes(this);
awindowgui.C: 		mwindow->theme->alist_x, 
awindowgui.C:    	mwindow->theme->alist_y, 
awindowgui.C:    	mwindow->theme->alist_w, 
awindowgui.C:    	mwindow->theme->alist_h));
awindowgui.C:		mwindow->theme->adivider_x,
awindowgui.C:		mwindow->theme->adivider_y,
awindowgui.C:		mwindow->theme->adivider_w,
awindowgui.C:		mwindow->theme->adivider_h));
awindowgui.C:	divider->set_cursor(HSEPARATE_CURSOR);
awindowgui.C: 		mwindow->theme->afolders_x, 
awindowgui.C:    	mwindow->theme->afolders_y, 
awindowgui.C:    	mwindow->theme->afolders_w, 
awindowgui.C:    	mwindow->theme->afolders_h));
awindowgui.C:	x = mwindow->theme->abuttons_x;
awindowgui.C:	y = mwindow->theme->abuttons_y;
awindowgui.C:	asset_menu->create_objects();
awindowgui.C:	assetlist_menu->create_objects();
awindowgui.C:	folderlist_menu->create_objects();
awindowgui.C:	mwindow->session->awindow_x = get_x();
awindowgui.C:	mwindow->session->awindow_y = get_y();
awindowgui.C:	mwindow->session->awindow_w = w;
awindowgui.C:	mwindow->session->awindow_h = h;
awindowgui.C:	mwindow->theme->get_awindow_sizes(this);
awindowgui.C:	mwindow->theme->draw_awindow_bg(this);
awindowgui.C:	asset_list->reposition_window(mwindow->theme->alist_x, 
awindowgui.C:    	mwindow->theme->alist_y, 
awindowgui.C:    	mwindow->theme->alist_w, 
awindowgui.C:    	mwindow->theme->alist_h);
awindowgui.C:	divider->reposition_window(mwindow->theme->adivider_x,
awindowgui.C:		mwindow->theme->adivider_y,
awindowgui.C:		mwindow->theme->adivider_w,
awindowgui.C:		mwindow->theme->adivider_h);
awindowgui.C:	folder_list->reposition_window(mwindow->theme->afolders_x, 
awindowgui.C:    	mwindow->theme->afolders_y, 
awindowgui.C:    	mwindow->theme->afolders_w, 
awindowgui.C:    	mwindow->theme->afolders_h);
awindowgui.C:	int x = mwindow->theme->abuttons_x;
awindowgui.C:	int y = mwindow->theme->abuttons_y;
awindowgui.C:// 	new_bin->reposition_window(x, y);
awindowgui.C:// 	x += new_bin->get_w();
awindowgui.C:// 	delete_bin->reposition_window(x, y);
awindowgui.C:// 	x += delete_bin->get_w();
awindowgui.C:// 	rename_bin->reposition_window(x, y);
awindowgui.C:// 	x += rename_bin->get_w();
awindowgui.C:// 	delete_disk->reposition_window(x, y);
awindowgui.C:// 	x += delete_disk->get_w();
awindowgui.C:// 	delete_project->reposition_window(x, y);
awindowgui.C:// 	x += delete_project->get_w();
awindowgui.C:// 	info->reposition_window(x, y);
awindowgui.C:// 	x += info->get_w();
awindowgui.C:// 	redraw_index->reposition_window(x, y);
awindowgui.C:// 	x += redraw_index->get_w();
awindowgui.C:// 	paste->reposition_window(x, y);
awindowgui.C:// 	x += paste->get_w();
awindowgui.C:// 	append->reposition_window(x, y);
awindowgui.C:// 	x += append->get_w();
awindowgui.C:// 	view->reposition_window(x, y);
awindowgui.C:	mwindow->session->awindow_x = get_x();
awindowgui.C:	mwindow->session->awindow_y = get_y();
awindowgui.C:	mwindow->theme->get_awindow_sizes(this);
awindowgui.C:	asset_list->reposition_window(mwindow->theme->alist_x, 
awindowgui.C:    	mwindow->theme->alist_y, 
awindowgui.C:    	mwindow->theme->alist_w, 
awindowgui.C:    	mwindow->theme->alist_h);
awindowgui.C:	divider->reposition_window(mwindow->theme->adivider_x,
awindowgui.C:		mwindow->theme->adivider_y,
awindowgui.C:		mwindow->theme->adivider_w,
awindowgui.C:		mwindow->theme->adivider_h);
awindowgui.C:	folder_list->reposition_window(mwindow->theme->afolders_x, 
awindowgui.C:    	mwindow->theme->afolders_y, 
awindowgui.C:    	mwindow->theme->afolders_w, 
awindowgui.C:    	mwindow->theme->afolders_h);
awindowgui.C:	mwindow->session->show_awindow = 0;
awindowgui.C:	mwindow->gui->lock_window();
awindowgui.C:	mwindow->gui->mainmenu->show_awindow->set_checked(0);
awindowgui.C:	mwindow->gui->unlock_window();
awindowgui.C:	mwindow->save_defaults();
awindowgui.C:		picon->in_use--;
awindowgui.C:	for(int i = 0; i < mwindow->edl->folders.total; i++)
awindowgui.C:		char *folder = mwindow->edl->folders.values[i];
awindowgui.C:			if(!strcasecmp(picon->get_text(), folder))
awindowgui.C:				picon->in_use = 1;
awindowgui.C:			picon->create_objects();
awindowgui.C://	printf("AWindowGUI::update_folder_list %s\n", folders.values[i]->get_text());
awindowgui.C:	for(int i = folders.total - 1; i >= 0; i--)
awindowgui.C:		if(!picon->in_use && !picon->persistent)
awindowgui.C://	printf("AWindowGUI::update_folder_list %s\n", folders.values[i]->get_text());
awindowgui.C:	mwindow->create_plugindb(do_audio, 
awindowgui.C:			picon->create_objects();
awindowgui.C:			output->append(picon);
awindowgui.C:		picon->in_use--;
awindowgui.C:	for(int i = 0; i < mwindow->edl->clips.total; i++)
awindowgui.C:			if(picon->id == mwindow->edl->clips.values[i]->id)
awindowgui.C:				picon->edl = mwindow->edl->clips.values[i];
awindowgui.C:				picon->set_text(mwindow->edl->clips.values[i]->local_session->clip_title);
awindowgui.C:				picon->in_use = 1;
awindowgui.C:				mwindow->edl->clips.values[i]);
awindowgui.C:			picon->create_objects();
awindowgui.C:	for(Asset *current = mwindow->edl->assets->first; 
awindowgui.C://printf("AWindowGUI::update_asset_list 3 %s\n", current->path);
awindowgui.C:			if(picon->id == current->id)
awindowgui.C://printf("AWindowGUI::update_asset_list 4 %p %d %d\n", picon->asset, picon->get_icon_x(), picon->get_icon_y());
awindowgui.C:				picon->asset = current;
awindowgui.C:				picon->in_use = 1;
awindowgui.C://printf("AWindowGUI::update_asset_list 4.1 %s\n", current->path);
awindowgui.C://printf("AWindowGUI::update_asset_list 4.2 %s\n", current->path);
awindowgui.C:			picon->create_objects();
awindowgui.C://printf("AWindowGUI::update_asset_list 4.3 %s\n", current->path);
awindowgui.C://printf("AWindowGUI::update_asset_list 4.4 %s\n", current->path);
awindowgui.C:	for(int i = assets.total - 1; i >= 0; i--)
awindowgui.C://printf("AWindowGUI::update_asset_list %s %d\n", picon->asset->path, picon->in_use);
awindowgui.C:		if(!picon->in_use)
awindowgui.C://printf("AWindowGUI::sort_assets 1 %s\n", mwindow->edl->session->current_folder);
awindowgui.C:	if(!strcasecmp(mwindow->edl->session->current_folder, AEFFECT_FOLDER))
awindowgui.C:	if(!strcasecmp(mwindow->edl->session->current_folder, VEFFECT_FOLDER))
awindowgui.C:	if(!strcasecmp(mwindow->edl->session->current_folder, ATRANSITION_FOLDER))
awindowgui.C:	if(!strcasecmp(mwindow->edl->session->current_folder, VTRANSITION_FOLDER))
awindowgui.C:			mwindow->edl->session->current_folder);
awindowgui.C:	mwindow->session->drag_assets->remove_all();
awindowgui.C:	mwindow->session->drag_clips->remove_all();
awindowgui.C:		AssetPicon *result = (AssetPicon*)asset_list->get_selection(0, i++);
awindowgui.C:		if(result->asset) mwindow->session->drag_assets->append(result->asset);
awindowgui.C:		if(result->edl) mwindow->session->drag_clips->append(result->edl);
awindowgui.C:	for(int i = 0; i < src->total; i++)
awindowgui.C:		AssetPicon *picon = (AssetPicon*)src->values[i];
awindowgui.C://printf("AWindowGUI::copy_picons 2 %s\n", picon->asset->folder);
awindowgui.C:			(folder && picon->asset && !strcasecmp(picon->asset->folder, folder)) ||
awindowgui.C:			(folder && picon->edl && !strcasecmp(picon->edl->local_session->folder, folder)))
awindowgui.C:			if(picon->edl)
awindowgui.C:				dst[1].append(item2 = new BC_ListBoxItem(picon->edl->local_session->clip_notes));
awindowgui.C:			item1->set_autoplace_text(1);
awindowgui.C:			item2->set_autoplace_text(1);
awindowgui.C://printf("AWindowGUI::copy_picons 3 %s\n", picon->get_text());
awindowgui.C:		for(int i = 0; i < src->total - 1; i++)
awindowgui.C:			BC_ListBoxItem *item1 = src->values[i];
awindowgui.C:			BC_ListBoxItem *item2 = src->values[i + 1];
awindowgui.C:			item1->set_autoplace_icon(1);
awindowgui.C:			item2->set_autoplace_icon(1);
awindowgui.C:			item1->set_autoplace_text(1);
awindowgui.C:			item2->set_autoplace_text(1);
awindowgui.C:			if(strcmp(item1->get_text(), item2->get_text()) > 0)
awindowgui.C:				src->values[i + 1] = item1;
awindowgui.C:				src->values[i] = item2;
awindowgui.C:	if(!strcasecmp(mwindow->edl->session->current_folder, AEFFECT_FOLDER))
awindowgui.C:	if(!strcasecmp(mwindow->edl->session->current_folder, VEFFECT_FOLDER))
awindowgui.C:	if(!strcasecmp(mwindow->edl->session->current_folder, ATRANSITION_FOLDER))
awindowgui.C:	if(!strcasecmp(mwindow->edl->session->current_folder, VTRANSITION_FOLDER))
awindowgui.C:			mwindow->edl->session->current_folder);
awindowgui.C://	printf("AWindowGUI::update_assets %s\n", folders.values[i]->get_text());
awindowgui.C:	if(mwindow->edl->session->folderlist_format != folder_list->get_format())
awindowgui.C:		folder_list->update_format(mwindow->edl->session->folderlist_format, 0);
awindowgui.C:	folder_list->update(&folders,
awindowgui.C:		folder_list->get_xposition(),
awindowgui.C:		folder_list->get_yposition(),
awindowgui.C:		-1);
awindowgui.C:	if(mwindow->edl->session->assetlist_format != asset_list->get_format())
awindowgui.C:		asset_list->update_format(mwindow->edl->session->assetlist_format, 0);
awindowgui.C:	asset_list->update(displayed_assets,
awindowgui.C:		mwindow->edl->session->asset_columns,
awindowgui.C:		asset_list->get_xposition(),
awindowgui.C:		asset_list->get_yposition(),
awindowgui.C:		-1,
awindowgui.C:	int result = -1;
awindowgui.C:		if(!strcasecmp(folders.values[i]->get_text(), mwindow->edl->session->current_folder))
awindowgui.C:	AssetPicon *picon = (AssetPicon*)asset_list->get_selection(0, 0);
awindowgui.C:	if(picon) return picon->asset;
awindowgui.C:	AssetPicon *picon = (AssetPicon*)asset_list->get_selection(0, 0);
awindowgui.C:	if(picon) return picon->plugin;
awindowgui.C:	AssetPicon *picon = (AssetPicon*)folder_list->get_selection(0, 0);
awindowgui.C:	this->mwindow = mwindow;
awindowgui.C:	this->gui = gui;
awindowgui.C:		mwindow->session->current_operation = DRAG_PARTITION;
awindowgui.C:	if(mwindow->session->current_operation == DRAG_PARTITION)
awindowgui.C:		mwindow->session->afolders_w = gui->get_relative_cursor_x();
awindowgui.C:		gui->reposition_objects();
awindowgui.C:	if(mwindow->session->current_operation == DRAG_PARTITION)
awindowgui.C:		mwindow->session->current_operation = NO_OPERATION;
awindowgui.C:		mwindow->edl->session->folderlist_format == FOLDERS_ICONS ? 
awindowgui.C:		&gui->folders, // Each column has an ArrayList of BC_ListBoxItems.
awindowgui.C:	this->mwindow = mwindow;
awindowgui.C:	this->gui = gui;
awindowgui.C:		strcpy(mwindow->edl->session->current_folder, picon->get_text());
awindowgui.C:		gui->asset_list->draw_background();
awindowgui.C:		gui->update_assets();
awindowgui.C:			gui->folderlist_menu->update_titles();
awindowgui.C:			gui->folderlist_menu->activate_menu();
awindowgui.C:		mwindow->edl->session->assetlist_format == ASSETS_ICONS ? 
awindowgui.C:		&gui->assets,  	  // Each column has an ArrayList of BC_ListBoxItems.
awindowgui.C:		gui->asset_titles,             // Titles for columns.  Set to 0 for no titles
awindowgui.C:		mwindow->edl->session->asset_columns,                // width of each column
awindowgui.C:	this->mwindow = mwindow;
awindowgui.C:	this->gui = gui;
awindowgui.C:		gui->assetlist_menu->update_titles();
awindowgui.C:		gui->assetlist_menu->activate_menu();
awindowgui.C:		if(!strcasecmp(mwindow->edl->session->current_folder, AEFFECT_FOLDER))
awindowgui.C:		if(!strcasecmp(mwindow->edl->session->current_folder, VEFFECT_FOLDER))
awindowgui.C:		if(!strcasecmp(mwindow->edl->session->current_folder, ATRANSITION_FOLDER))
awindowgui.C:		if(!strcasecmp(mwindow->edl->session->current_folder, VTRANSITION_FOLDER))
awindowgui.C:			mwindow->vwindow->gui->lock_window();
awindowgui.C:			if(((AssetPicon*)get_selection(0, 0))->asset)
awindowgui.C:				mwindow->vwindow->change_source(((AssetPicon*)get_selection(0, 0))->asset);
awindowgui.C:			if(((AssetPicon*)get_selection(0, 0))->edl)
awindowgui.C:				mwindow->vwindow->change_source(((AssetPicon*)get_selection(0, 0))->edl);
awindowgui.C:			mwindow->vwindow->gui->unlock_window();
awindowgui.C:		if(!strcasecmp(mwindow->edl->session->current_folder, AEFFECT_FOLDER) || 
awindowgui.C:			!strcasecmp(mwindow->edl->session->current_folder, VEFFECT_FOLDER) ||
awindowgui.C:			!strcasecmp(mwindow->edl->session->current_folder, ATRANSITION_FOLDER) ||
awindowgui.C:			!strcasecmp(mwindow->edl->session->current_folder, VTRANSITION_FOLDER))
awindowgui.C:			gui->assetlist_menu->update_titles();
awindowgui.C:			gui->assetlist_menu->activate_menu();
awindowgui.C:			if(((AssetPicon*)get_selection(0, 0))->asset)
awindowgui.C:				gui->asset_menu->update();
awindowgui.C:			if(((AssetPicon*)get_selection(0, 0))->edl)
awindowgui.C:				gui->asset_menu->update();
awindowgui.C:			gui->asset_menu->activate_menu();
awindowgui.C://printf("AWindowAssets::draw_background %s\n", mwindow->edl->session->current_folder);
awindowgui.C:	draw_text(get_w() - 
awindowgui.C:			get_text_width(LARGEFONT, mwindow->edl->session->current_folder) - 4, 
awindowgui.C:		mwindow->edl->session->current_folder, 
awindowgui.C:		-1, 
awindowgui.C:		if(!strcasecmp(mwindow->edl->session->current_folder, AEFFECT_FOLDER))
awindowgui.C:			mwindow->session->current_operation = DRAG_AEFFECT;
awindowgui.C:		if(!strcasecmp(mwindow->edl->session->current_folder, VEFFECT_FOLDER))
awindowgui.C:			mwindow->session->current_operation = DRAG_VEFFECT;
awindowgui.C:		if(!strcasecmp(mwindow->edl->session->current_folder, ATRANSITION_FOLDER))
awindowgui.C:			mwindow->session->current_operation = DRAG_ATRANSITION;
awindowgui.C:		if(!strcasecmp(mwindow->edl->session->current_folder, VTRANSITION_FOLDER))
awindowgui.C:			mwindow->session->current_operation = DRAG_VTRANSITION;
awindowgui.C:			mwindow->session->current_operation = DRAG_ASSET;
awindowgui.C:			mwindow->session->drag_pluginservers->remove_all();
awindowgui.C:				mwindow->session->drag_pluginservers->append(result->plugin);
awindowgui.C:			gui->collect_assets();
awindowgui.C:	mwindow->gui->lock_window();
awindowgui.C:	mwindow->gui->drag_motion();
awindowgui.C:	mwindow->gui->unlock_window();
awindowgui.C:	mwindow->vwindow->gui->lock_window();
awindowgui.C:	mwindow->vwindow->gui->drag_motion();
awindowgui.C:	mwindow->vwindow->gui->unlock_window();
awindowgui.C:	mwindow->cwindow->gui->lock_window();
awindowgui.C:	mwindow->cwindow->gui->drag_motion();
awindowgui.C:	mwindow->cwindow->gui->unlock_window();
awindowgui.C:	result = gui->drag_stop();
awindowgui.C:		mwindow->gui->lock_window();
awindowgui.C:		result = mwindow->gui->drag_stop();
awindowgui.C:		mwindow->gui->unlock_window();
awindowgui.C:		mwindow->vwindow->gui->lock_window();
awindowgui.C:		result = mwindow->vwindow->gui->drag_stop();
awindowgui.C:		mwindow->vwindow->gui->unlock_window();
awindowgui.C:		mwindow->cwindow->gui->lock_window();
awindowgui.C:		result = mwindow->cwindow->gui->drag_stop();
awindowgui.C:		mwindow->cwindow->gui->unlock_window();
awindowgui.C:	if(result) get_drag_popup()->set_animation(0);
awindowgui.C:	mwindow->edl->session->asset_columns[0] = get_column_width(0);
awindowgui.C:	mwindow->edl->session->asset_columns[1] = get_column_width(1);
awindowgui.C: : BC_Button(x, y, mwindow->theme->newbin_data)
awindowgui.C:	this->mwindow = mwindow;
awindowgui.C:	this->gui = gui;
awindowgui.C:	gui->newfolder_thread->start_new_folder();
awindowgui.C: : BC_Button(x, y, mwindow->theme->deletebin_data)
awindowgui.C:	this->mwindow = mwindow;
awindowgui.C:	this->gui = gui;
awindowgui.C:	if(gui->folder_list->get_selection(0, 0))
awindowgui.C:		BC_ListBoxItem *folder = gui->folder_list->get_selection(0, 0);
awindowgui.C:		mwindow->delete_folder(folder->get_text());
awindowgui.C: : BC_Button(x, y, mwindow->theme->renamebin_data)
awindowgui.C:	this->mwindow = mwindow;
awindowgui.C:	this->gui = gui;
awindowgui.C: : BC_Button(x, y, mwindow->theme->deletedisk_data)
awindowgui.C:	this->mwindow = mwindow;
awindowgui.C:	this->gui = gui;
awindowgui.C: : BC_Button(x, y, mwindow->theme->deleteproject_data)
awindowgui.C:	this->mwindow = mwindow;
awindowgui.C:	this->gui = gui;
awindowgui.C: : BC_Button(x, y, mwindow->theme->infoasset_data)
awindowgui.C:	this->mwindow = mwindow;
awindowgui.C:	this->gui = gui;
awindowgui.C:	gui->awindow->asset_edit->edit_asset(gui->selected_asset());
awindowgui.C: : BC_Button(x, y, mwindow->theme->redrawindex_data)
awindowgui.C:	this->mwindow = mwindow;
awindowgui.C:	this->gui = gui;
awindowgui.C: : BC_Button(x, y, mwindow->theme->pasteasset_data)
awindowgui.C:	this->mwindow = mwindow;
awindowgui.C:	this->gui = gui;
awindowgui.C: : BC_Button(x, y, mwindow->theme->appendasset_data)
awindowgui.C:	this->mwindow = mwindow;
awindowgui.C:	this->gui = gui;
awindowgui.C: : BC_Button(x, y, mwindow->theme->viewasset_data)
awindowgui.C:	this->mwindow = mwindow;
awindowgui.C:	this->gui = gui;
awindowmenu.C:	this->mwindow = mwindow;
awindowmenu.C:	this->gui = gui;
awindowmenu.C:	format->update();
awindowmenu.C:	this->mwindow = mwindow;
awindowmenu.C:	set_text(mwindow->edl->session->assetlist_format == ASSETS_TEXT ?
awindowmenu.C:	switch(mwindow->edl->session->assetlist_format)
awindowmenu.C:			mwindow->edl->session->assetlist_format = ASSETS_ICONS;
awindowmenu.C:			mwindow->edl->session->assetlist_format = ASSETS_TEXT;
awindowmenu.C:	mwindow->awindow->gui->asset_list->update_format(
awindowmenu.C:		mwindow->edl->session->assetlist_format, 
awindowmenu.C:	this->mwindow = mwindow;
awindowmenu.C:	mwindow->awindow->gui->sort_assets();
awindowmenu.C:	this->mwindow = mwindow;
awindowmenu.C:	this->gui = gui;
awindowmenu.C:	format->set_text(mwindow->edl->session->folderlist_format == FOLDERS_TEXT ?
awindowmenu.C:	this->mwindow = mwindow;
awindowmenu.C:	this->menu = menu;
awindowmenu.C:	switch(mwindow->edl->session->folderlist_format)
awindowmenu.C:			mwindow->edl->session->folderlist_format = ASSETS_ICONS;
awindowmenu.C:			mwindow->edl->session->folderlist_format = ASSETS_TEXT;
awindowmenu.C:	mwindow->awindow->gui->folder_list->update_format(mwindow->edl->session->folderlist_format, 1);
awindowmenu.C:	menu->update_titles();
batch.C:	this->mwindow = mwindow;
batch.C:	this->record = record;
batch.C:	while(labels->last) delete labels->last;
batch.C:	enabled = batch->enabled;
batch.C:	channel = batch->channel;
batch.C:	start_type = batch->start_type;
batch.C:	duration = batch->duration;
batch.C:	start_time = batch->start_time;
batch.C:	start_day = batch->start_day;
batch.C:	record_mode = batch->record_mode;
batch.C:	if(record->get_current_batch() == this && record->file)
batch.C:		FILE *test = fopen(get_current_asset()->path, "r");
batch.C:	char *path = get_current_asset()->path;
batch.C:	int i, j = -1, k = -1;
batch.C:	int number = record->batches.total;
batch.C:	strcpy(string, record->default_asset->path);
batch.C:	strcpy(path, record->default_asset->path);
batch.C:	sprintf(&path[j], "%d", record->batches.total);
batch.C:	if(record->current_channeldb())
batch.C:		if(channel >= 0 && channel < record->current_channeldb()->total)
batch.C:			return record->current_channeldb()->values[channel];
batch.C:		return channel->title;
batch.C:	labels->toggle_label(position);
batchrender.C:	this->mwindow = mwindow;
batchrender.C:	mwindow->batch_render->start();
batchrender.C:	this->mwindow = mwindow;
batchrender.C:	asset->copy_from(src->asset, 0);
batchrender.C:	strcpy(edl_path, src->edl_path);
batchrender.C:	strategy = src->strategy;
batchrender.C:	enabled = src->enabled;
batchrender.C:	file->tag.get_property("EDL_PATH", edl_path);
batchrender.C:	strategy = file->tag.get_property("STRATEGY", strategy);
batchrender.C:	enabled = file->tag.get_property("ENABLED", enabled);
batchrender.C:	elapsed = file->tag.get_property("ELAPSED", elapsed);
batchrender.C:	result = file->read_tag();
batchrender.C:		if(file->tag.title_is("ASSET"))
batchrender.C:			file->tag.get_property("SRC", asset->path);
batchrender.C:			asset->read(file, 0);
batchrender.C:	file->tag.set_property("EDL_PATH", edl_path);
batchrender.C:	file->tag.set_property("STRATEGY", strategy);
batchrender.C:	file->tag.set_property("ENABLED", enabled);
batchrender.C:	file->tag.set_property("ELAPSED", elapsed);
batchrender.C:	file->append_tag();
batchrender.C:	file->append_newline();
batchrender.C:	asset->write(file,
batchrender.C:	file->tag.set_title("/JOB");
batchrender.C:	file->append_tag();
batchrender.C:	file->append_newline();
batchrender.C:	strategy = Render::fix_strategy(strategy, mwindow->preferences->use_renderfarm);
batchrender.C:	this->mwindow = mwindow;
batchrender.C:	rendering_job = -1;
batchrender.C:	this->gui = new BatchRenderGUI(mwindow, 
batchrender.C:		mwindow->session->batchrender_x,
batchrender.C:		mwindow->session->batchrender_y,
batchrender.C:		mwindow->session->batchrender_w,
batchrender.C:		mwindow->session->batchrender_h);
batchrender.C:	this->gui->create_objects();
batchrender.C:	return this->gui;
batchrender.C:				job->load(&file);
batchrender.C:		jobs.values[i]->save(&file);
batchrender.C:	default_job->asset->load_defaults(mwindow->defaults,
batchrender.C:	default_job->fix_strategy();
batchrender.C:		column_width[i] = mwindow->defaults->get(string, list_widths[i]);
batchrender.C://	current_job = mwindow->defaults->get("BATCHRENDER_JOB", 0);
batchrender.C:	default_job->asset->save_defaults(mwindow->defaults,
batchrender.C:	mwindow->defaults->update("BATCHRENDER_STRATEGY", default_job->strategy);
batchrender.C:		mwindow->defaults->update(string, column_width[i]);
batchrender.C://	mwindow->defaults->update("BATCHRENDER_JOB", current_job);
batchrender.C:	mwindow->save_defaults();
batchrender.C:	result->copy_from(get_current_job());
batchrender.C:	current_job = jobs.total - 1;
batchrender.C:	gui->create_list(1);
batchrender.C:	gui->change_job();
batchrender.C:		if(current_job > 0) current_job--;
batchrender.C:		gui->create_list(1);
batchrender.C:		gui->change_job();
batchrender.C:	return get_current_job()->asset;
batchrender.C:	return get_current_job()->edl_path;
batchrender.C:	gui->new_batch->disable();
batchrender.C:	gui->delete_batch->disable();
batchrender.C:		if(jobs.values[i]->enabled)
batchrender.C:			FILE *fd = fopen(jobs.values[i]->edl_path, "r");
batchrender.C:					mwindow->gui->get_abs_cursor_x(),
batchrender.C:					mwindow->gui->get_abs_cursor_y());
batchrender.C:				sprintf(string, _("EDL %s not found.\n"), jobs.values[i]->edl_path);
batchrender.C:				gui->new_batch->enable();
batchrender.C:				gui->delete_batch->enable();
batchrender.C:		if(job->enabled)
batchrender.C:			file->read_from_file(job->edl_path);
batchrender.C:			command->command = NORMAL_FWD;
batchrender.C:			command->get_edl()->load_xml(mwindow->plugindb, 
batchrender.C:			command->change_type = CHANGE_ALL;
batchrender.C:			command->set_playback_range();
batchrender.C:			command->adjust_playback_range();
batchrender.C:			packages->create_packages(mwindow,
batchrender.C:				command->get_edl(),
batchrender.C:				mwindow->preferences,
batchrender.C:				job->strategy, 
batchrender.C:				job->asset, 
batchrender.C:				command->start_position, 
batchrender.C:				command->end_position,
batchrender.C:			for(int j = 0; j < packages->get_total_packages(); j++)
batchrender.C:				RenderPackage *package = packages->get_package(j);
batchrender.C:				paths.append(strdup(package->path));
batchrender.C:		gui->new_batch->enable();
batchrender.C:		gui->delete_batch->enable();
batchrender.C:	mwindow->render->start_batches(&jobs);
batchrender.C:	mwindow->render->stop_operation();
batchrender.C:	gui->lock_window("BatchRenderThread::update_active");
batchrender.C:		rendering_job = -1;
batchrender.C:	gui->create_list(1);
batchrender.C:	gui->unlock_window();
batchrender.C:	gui->lock_window("BatchRenderThread::update_done");
batchrender.C:		gui->new_batch->enable();
batchrender.C:		gui->delete_batch->enable();
batchrender.C:		jobs.values[number]->enabled = 0;
batchrender.C:		jobs.values[number]->elapsed = elapsed_time;
batchrender.C:		if(create_list) gui->create_list(1);
batchrender.C:	gui->unlock_window();
batchrender.C:	if(dst < 0) dst = jobs.total - 1;
batchrender.C:		for(int i = src; i < jobs.total - 1; i++)
batchrender.C://		if(dst > src) dst--;
batchrender.C:		for(int i = jobs.total - 1; i > dst; i--)
batchrender.C:			jobs.values[i] = jobs.values[i - 1];
batchrender.C:		gui->create_list(1);
batchrender.C:	this->mwindow = mwindow;
batchrender.C:	this->thread = thread;
batchrender.C:	mwindow->theme->get_batchrender_sizes(this, get_w(), get_h());
batchrender.C:	int x = mwindow->theme->batchrender_x1;
batchrender.C:	int x1 = mwindow->theme->batchrender_x1;
batchrender.C:	int x2 = mwindow->theme->batchrender_x2;
batchrender.C:	int x3 = mwindow->theme->batchrender_x3;
batchrender.C:					thread->get_current_asset());
batchrender.C:	format_tools->create_objects(x, 
batchrender.C:						&thread->get_current_job()->strategy, 
batchrender.C:	x += format_tools->get_w();
batchrender.C:		get_w() - x - 40, 
batchrender.C:		thread->get_current_edl()));
batchrender.C:	x += edl_path_text->get_w();
batchrender.C:		thread->get_current_edl(),
batchrender.C:	x += new_batch->get_w() + 10;
batchrender.C:	x += delete_batch->get_w() + 10;
batchrender.C:		get_w() - x - 10,
batchrender.C:		get_h() - y - 50));
batchrender.C:	y += batch_list->get_h() + 10;
batchrender.C:	x = get_w() / 2 -
batchrender.C:		mwindow->theme->get_image_set("batch_render_stop")[0]->get_w() / 2;
batchrender.C:	x = get_w() - 
batchrender.C:		mwindow->theme->get_image_set("batch_render_cancel")[0]->get_w() - 
batchrender.C:	mwindow->session->batchrender_w = w;
batchrender.C:	mwindow->session->batchrender_h = h;
batchrender.C:	mwindow->theme->get_batchrender_sizes(this, w, h);
batchrender.C:	int x = mwindow->theme->batchrender_x1;
batchrender.C:	int x1 = mwindow->theme->batchrender_x1;
batchrender.C:	int x2 = mwindow->theme->batchrender_x2;
batchrender.C:	int x3 = mwindow->theme->batchrender_x3;
batchrender.C:	output_path_title->reposition_window(x1, y);
batchrender.C:	format_tools->reposition_window(x, y);
batchrender.C:	x += format_tools->get_w();
batchrender.C:	edl_path_title->reposition_window(x, y);
batchrender.C:	edl_path_text->reposition_window(x, y, w - x - 40);
batchrender.C:	x += edl_path_text->get_w();
batchrender.C:	edl_path_browse->reposition_window(x, y);
batchrender.C:// 	status_title->reposition_window(x, y);
batchrender.C:// 	status_text->reposition_window(x, y);
batchrender.C:// 	progress_bar->reposition_window(x, y, w - x - 10);
batchrender.C:	new_batch->reposition_window(x, y);
batchrender.C:	x += new_batch->get_w() + 10;
batchrender.C:	delete_batch->reposition_window(x, y);
batchrender.C:	x += delete_batch->get_w() + 10;
batchrender.C:	list_title->reposition_window(x, y);
batchrender.C:	batch_list->reposition_window(x, y, w - x - 10, h - y - 50);
batchrender.C:	y += batch_list->get_h() + 10;
batchrender.C:	start_button->reposition_window(x, y);
batchrender.C:	x = w / 2 - 
batchrender.C:		mwindow->theme->get_image_set("batch_render_stop")[0]->get_w() / 2;
batchrender.C:	stop_button->reposition_window(x, y);
batchrender.C:	x = w -
batchrender.C:		mwindow->theme->get_image_set("batch_render_cancel")[0]->get_w() - 
batchrender.C:	cancel_button->reposition_window(x, y);
batchrender.C:	mwindow->session->batchrender_x = get_x();
batchrender.C:	mwindow->session->batchrender_y = get_y();
batchrender.C:	thread->stop_rendering();
batchrender.C:	for(int i = 0; i < thread->jobs.total; i++)
batchrender.C:		BatchRenderJob *job = thread->jobs.values[i];
batchrender.C:		BC_ListBoxItem *enabled = new BC_ListBoxItem(job->enabled ? 
batchrender.C:		BC_ListBoxItem *item1 = new BC_ListBoxItem(job->asset->path);
batchrender.C:		BC_ListBoxItem *item2 = new BC_ListBoxItem(job->edl_path);
batchrender.C:		if(job->elapsed)
batchrender.C:					job->elapsed,
batchrender.C:		if(i == thread->current_job)
batchrender.C:			enabled->set_selected(1);
batchrender.C:			item1->set_selected(1);
batchrender.C:			item2->set_selected(1);
batchrender.C:			item3->set_selected(1);
batchrender.C:		if(i == thread->rendering_job)
batchrender.C:			enabled->set_color(RED);
batchrender.C:			item1->set_color(RED);
batchrender.C:			item2->set_color(RED);
batchrender.C:			item3->set_color(RED);
batchrender.C:		batch_list->update(list_columns,
batchrender.C:						thread->column_width,
batchrender.C:						batch_list->get_xposition(),
batchrender.C:						batch_list->get_yposition(), 
batchrender.C:						batch_list->get_highlighted_item(),  // Flat index of item cursor is over
batchrender.C:	BatchRenderJob *job = thread->get_current_job();
batchrender.C:	format_tools->update(job->asset, &job->strategy);
batchrender.C:	edl_path_text->update(job->edl_path);
batchrender.C:	this->gui = gui;
batchrender.C:	this->mwindow = mwindow;
batchrender.C:	gui->create_list(1);
batchrender.C:	this->thread = thread;
batchrender.C:	strcpy(thread->get_current_edl(), get_text());
batchrender.C:	thread->gui->create_list(1);
batchrender.C:	this->thread = thread;
batchrender.C:	thread->new_job();
batchrender.C:	this->thread = thread;
batchrender.C:	thread->delete_job();
batchrender.C:	thread->gui->list_columns,
batchrender.C:	thread->column_width,
batchrender.C:	this->thread = thread;
batchrender.C:	thread->current_job = get_selection_number(0, 0);
batchrender.C:	thread->gui->change_job();
batchrender.C:	if(get_cursor_x() < thread->column_width[0])
batchrender.C:		BatchRenderJob *job = thread->get_current_job();
batchrender.C:		job->enabled = !job->enabled;
batchrender.C:		thread->gui->create_list(1);
batchrender.C:		thread->column_width[i] = get_column_width(i);
batchrender.C:			thread->move_batch(src, dst);
batchrender.C:	thread->mwindow->theme->get_image_set(_("batch_render_start")))
batchrender.C:	this->thread = thread;
batchrender.C:	thread->start_rendering();
batchrender.C:	thread->mwindow->theme->get_image_set(_("batch_render_stop")))
batchrender.C:	this->thread = thread;
batchrender.C:	thread->stop_rendering();
batchrender.C:	thread->mwindow->theme->get_image_set(_("batch_render_cancel")))
batchrender.C:	this->thread = thread;
batchrender.C:	thread->stop_rendering();
batchrender.C:	thread->gui->set_done(1);
batchrender.C:		thread->stop_rendering();
batchrender.C:		thread->gui->set_done(1);
bezierauto.C:	return EQUIV(center_x, src->center_x) &&
bezierauto.C:		EQUIV(center_y, src->center_y) &&
bezierauto.C:		EQUIV(center_z, src->center_z) &&
bezierauto.C:		EQUIV(control_in_x, src->control_in_x) &&
bezierauto.C:		EQUIV(control_in_y, src->control_in_y) &&
bezierauto.C:		EQUIV(control_out_x, src->control_out_x) &&
bezierauto.C:		EQUIV(control_out_y, src->control_out_y) &&
bezierauto.C:		EQUIV(control_in_z, src->control_in_z) &&
bezierauto.C:		EQUIV(control_out_z, src->control_out_z) ;
bezierauto.C:	center_x = that->center_x;
bezierauto.C:	center_y = that->center_y;
bezierauto.C:	center_z = that->center_z;
bezierauto.C:	control_in_x = that->control_in_x;
bezierauto.C:	control_in_y = that->control_in_y;
bezierauto.C:	control_in_z = that->control_in_z;
bezierauto.C:	control_out_x = that->control_out_x;
bezierauto.C:	control_out_y = that->control_out_y;
bezierauto.C:	control_out_z = that->control_out_z;
bezierauto.C:	file->tag.set_title("AUTO");
bezierauto.C:		file->tag.set_property("POSITION", 0);
bezierauto.C:		file->tag.set_property("POSITION", position - start);
bezierauto.C:	file->tag.set_property("CENTER_X", center_x);
bezierauto.C:	file->tag.set_property("CENTER_Y", center_y);
bezierauto.C:	file->tag.set_property("CENTER_Z", center_z);
bezierauto.C:	file->tag.set_property("CONTROL_IN_X", control_in_x);
bezierauto.C:	file->tag.set_property("CONTROL_IN_Y", control_in_y);
bezierauto.C:	file->tag.set_property("CONTROL_IN_Z", control_in_z);
bezierauto.C:	file->tag.set_property("CONTROL_OUT_X", control_out_x);
bezierauto.C:	file->tag.set_property("CONTROL_OUT_Y", control_out_y);
bezierauto.C:	file->tag.set_property("CONTROL_OUT_Z", control_out_z);
bezierauto.C:	file->append_tag();
bezierauto.C:	file->append_newline();
bezierauto.C:	center_x = file->tag.get_property("CENTER_X", (float)0);
bezierauto.C:	center_y = file->tag.get_property("CENTER_Y", (float)0);
bezierauto.C:	center_z = file->tag.get_property("CENTER_Z", (float)1);
bezierauto.C:	control_in_x = file->tag.get_property("CONTROL_IN_X", (float)control_in_x);
bezierauto.C:	control_in_y = file->tag.get_property("CONTROL_IN_Y", (float)control_in_y);
bezierauto.C:	control_in_z = file->tag.get_property("CONTROL_IN_Z", (float)control_in_z);
bezierauto.C:	control_out_x = file->tag.get_property("CONTROL_OUT_X", (float)control_out_x);
bezierauto.C:	control_out_y = file->tag.get_property("CONTROL_OUT_Y", (float)control_out_y);
bezierauto.C:	control_out_z = file->tag.get_property("CONTROL_OUT_Z", (float)control_out_z);
bezierauto.C:// 	canvas->draw_disc(control_x[0] - WIDTH/2, control_y[0] - HEIGHT/2, WIDTH, HEIGHT);
bezierauto.C:			canvas->draw_box(control_x[i] - WIDTH/2, control_y[i] - HEIGHT/2, WIDTH, HEIGHT);
bezierauto.C:			canvas->draw_rectangle(control_x[i] - WIDTH/2, control_y[i] - HEIGHT/2, WIDTH, HEIGHT);
bezierauto.C:		canvas->draw_line(control_x[i], control_y[i], control_x[0], control_y[0]);
bezierauto.C:	if(show_value && ((BezierAutos*)autos)->selection_type > 1)
bezierauto.C:		text_x = control_x[((BezierAutos*)autos)->selection_type - 2] + 20;
bezierauto.C:		text_y = control_y[((BezierAutos*)autos)->selection_type - 2] + 20;
bezierauto.C:		//canvas->set_font(SMALLFONT);
bezierauto.C:		canvas->draw_text(text_x, text_y, string);
bezierauto.C:		//canvas->set_font(MEDIUMFONT);
bezierauto.C:	if(cursor_x > control_x[0] - WIDTH/2 &&
bezierauto.C:	cursor_y > control_y[0] - HEIGHT/2 &&
bezierauto.C:	if(cursor_x > x - WIDTH/2 &&
bezierauto.C:		cursor_y > y - HEIGHT/2 &&
bezierauto.C:// 	if(((x > center_x) ? cursor_x > center_x - WIDTH/2 : cursor_x > x - WIDTH/2) &&
bezierauto.C:// 		((y > center_y) ? cursor_y > center_y - HEIGHT/2 : cursor_y > y - HEIGHT/2) &&
bezierauto.C:// 		((y > center_y) ? cursor_y < y - HEIGHT/2 : cursor_y < center_y + HEIGHT/2))
bezierauto.C:// 		float A = cursor_x - center_x;
bezierauto.C:// 		float B = cursor_y - center_y;
bezierauto.C:// 		float C = x - center_x;
bezierauto.C:// 		float D = y - center_y;
bezierauto.C:// 		float dist = (A * D - B * C) / sqrt(C * C + D * D);
bezierauto.C:	return sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
bezierauto.C:	zoom_scale = ((BezierAutos*)autos)->frame_h * scale;
bezierauto.C:	if(((BezierAutos*)autos)->frame_w)
bezierauto.C:	switch(((BezierAutos*)autos)->selection_type)
bezierauto.C:	switch(((BezierAutos*)autos)->selection_type)
bezierautos.C:	this->center_x = center_x;
bezierautos.C:	this->center_y = center_y;
bezierautos.C:	this->center_z = center_z;
bezierautos.C:	this->virtual_w = virtual_w;
bezierautos.C:	this->virtual_h = virtual_h;
bezierautos.C:	int64_t frame = xml->tag.get_property("FRAME", 0);
bezierautos.C:	current->load(xml);
bezierautos.C:	current->position += start;   // fix the position loaded by load()
bezierautos.C:	result = (int)((position - view_start) / units_per_pixel) + frame_half;
bezierautos.C:	frame = (direction == PLAY_FORWARD) ? frame : (frame - 1);
bezierautos.C:		x = ((BezierAuto*)default_auto)->center_x;
bezierautos.C:		y = ((BezierAuto*)default_auto)->center_y;
bezierautos.C:		z = ((BezierAuto*)default_auto)->center_z;
bezierautos.C:		x0 = (*before)->center_x;
bezierautos.C:		y0 = (*before)->center_y;
bezierautos.C:		z0 = (*before)->center_z;
bezierautos.C:		frame0 = (float)(*before)->position;
bezierautos.C:		x1 = (*before)->control_out_x + x0;
bezierautos.C:		y1 = (*before)->control_out_y + y0;
bezierautos.C:		z1 = (*before)->control_out_z + z0;
bezierautos.C:		x3 = (*after)->center_x;
bezierautos.C:		y3 = (*after)->center_y;
bezierautos.C:		z3 = (*after)->center_z;
bezierautos.C:		frame1 = (float)(*after)->position;
bezierautos.C:		x2 = (*after)->control_in_x + x3;
bezierautos.C:		y2 = (*after)->control_in_y + y3;
bezierautos.C:		z2 = (*after)->control_in_z + z3;
bezierautos.C: 	float t = (frame - frame0) / (frame1 - frame0);
bezierautos.C:	float invt = 1 - t;
bezierautos.C:	z = t * (z3 - z0) + z0;
bezierautos.C:		new_selected->position = bezier_selected->position;
bezierautos.C:		new_selected->center_x = bezier_selected->center_x;
bezierautos.C:		new_selected->control_in_x = bezier_selected->control_in_x;
bezierautos.C:		new_selected->control_out_x = bezier_selected->control_out_x;
bezierautos.C:		new_selected->center_y = bezier_selected->center_y;
bezierautos.C:		new_selected->control_in_y = bezier_selected->control_in_y;
bezierautos.C:		new_selected->control_out_y = bezier_selected->control_out_y;
bezierautos.C:		new_selected->center_z = bezier_selected->center_z;
bezierautos.C:		new_selected->control_in_z = bezier_selected->control_in_z;
bezierautos.C:		new_selected->control_out_z = bezier_selected->control_out_z;
bezierautos.C:		bezier_selected->position = old_selected->position;
bezierautos.C:		bezier_selected->center_x = old_selected->center_x;
bezierautos.C:		bezier_selected->control_in_x = old_selected->control_in_x;
bezierautos.C:		bezier_selected->control_out_x = old_selected->control_out_x;
bezierautos.C:		bezier_selected->center_y = old_selected->center_y;
bezierautos.C:		bezier_selected->control_in_y = old_selected->control_in_y;
bezierautos.C:		bezier_selected->control_out_y = old_selected->control_out_y;
bezierautos.C:		bezier_selected->center_z = old_selected->center_z;
bezierautos.C:		bezier_selected->control_in_z = old_selected->control_in_z;
bezierautos.C:		bezier_selected->control_out_z = old_selected->control_out_z;
bezierautos.C:		bezier_selected->position = new_selected->position;
bezierautos.C:		bezier_selected->center_x = new_selected->center_x;
bezierautos.C:		bezier_selected->control_in_x = new_selected->control_in_x;
bezierautos.C:		bezier_selected->control_out_x = new_selected->control_out_x;
bezierautos.C:		bezier_selected->center_y = new_selected->center_y;
bezierautos.C:		bezier_selected->control_in_y = new_selected->control_in_y;
bezierautos.C:		bezier_selected->control_out_y = new_selected->control_out_y;
bezierautos.C:		bezier_selected->center_z = new_selected->center_z;
bezierautos.C:		bezier_selected->control_in_z = new_selected->control_in_z;
bezierautos.C:		bezier_selected->control_out_z = new_selected->control_out_z;
bezierautos.C:		skip = selected->skip;
bezierautos.C:		selected->skip = 0;
bezierautos.C:		view_end = view_start + units_per_pixel * (vertical ? canvas->get_h() : canvas->get_w());
bezierautos.C:		before = (BezierAuto*)selected->previous;
bezierautos.C:		after = (BezierAuto*)selected->next;
bezierautos.C:		frame1 = before ? before->position : view_start;
bezierautos.C:		frame2 = after ? after->position : view_end;
bezierautos.C:		canvas->set_inverse();
bezierautos.C:		canvas->set_color(WHITE);
bezierautos.C:// 		get_center(x1, y1, z1, frame1 - units_per_pixel, 0, &before, &after);
bezierautos.C:// 				canvas->draw_line(x1, x - 1, x2, x);
bezierautos.C:// 				canvas->draw_line(y1, x - 1, y2, x);
bezierautos.C:		x = get_auto_pixel(selected->position, view_start, units_per_pixel, get_frame_half(scale, vertical, units_per_pixel));
bezierautos.C:		((BezierAuto*)selected)->draw(canvas, x, center_pixel, scale, vertical, 1);
bezierautos.C:		canvas->set_opaque();		
bezierautos.C:		selected->skip = skip;
bezierautos.C:			canvas->flash(pixel, 0, zoom_track, canvas->get_h());
bezierautos.C:			canvas->flash(0, pixel, canvas->get_w(), zoom_track);
bezierautos.C:	view_end = view_start + units_per_pixel * (vertical ? canvas->get_h() : canvas->get_w());
bezierautos.C:	while(current && current->position <= view_end && !selection_type)
bezierautos.C:		x = get_auto_pixel(current->position, view_start, units_per_pixel, get_frame_half(scale, vertical, units_per_pixel));
bezierautos.C:		selection_type = ((BezierAuto*)current)->select(canvas, 
bezierautos.C:			current->skip = 1;
bezierautos.C://		miny = (int)(y * scale + center_pixel - 5);
bezierautos.C:		miny = center_pixel - 5;
bezierautos.C:			if(selected->previous)
bezierautos.C:				neighbor = (BezierAuto*)selected->previous;
bezierautos.C:			if(selected->next)
bezierautos.C:				neighbor = (BezierAuto*)selected->next;
bezierautos.C:				bezier_selected->center_x = neighbor->center_x;
bezierautos.C:				bezier_selected->center_y = neighbor->center_y;
bezierautos.C:				bezier_selected->center_z = neighbor->center_z;
bezierautos.C:// 				bezier_selected->control_in_x = neighbor->control_in_x;
bezierautos.C:// 				bezier_selected->control_in_y = neighbor->control_in_y;
bezierautos.C:// 				bezier_selected->control_in_z = neighbor->control_in_z;
bezierautos.C:// 				bezier_selected->control_out_x = neighbor->control_out_x;
bezierautos.C:// 				bezier_selected->control_out_y = neighbor->control_out_y;
bezierautos.C:// 				bezier_selected->control_out_z = neighbor->control_out_z;
bezierautos.C:			selected->skip = 1;
bezierautos.C:				selected_x = current->center_x;
bezierautos.C:				selected_y = current->center_y;
bezierautos.C:				selected_y = current->center_z * virtual_h;
bezierautos.C:				selected_x = current->control_in_x;
bezierautos.C:				selected_y = current->control_in_y;
bezierautos.C:				selected_x = current->control_out_x;
bezierautos.C:				selected_y = current->control_out_y;
bezierautos.C:				selected_y = current->control_in_z * virtual_h;
bezierautos.C:				selected_y = current->control_out_z * virtual_h;
bezierautos.C:			x = center_x + cursor_x - selected_x;
bezierautos.C:		y = center_y + cursor_y - selected_y;
bezierautos.C:			if(position != current->position) result = 1;
bezierautos.C:			current->position = position;
bezierautos.C:				real_x = (float)((vertical ? cursor_y : cursor_x) - virtual_center_x);
bezierautos.C:			float real_y = (float)((vertical ? cursor_x : cursor_y) - virtual_center_y);
bezierautos.C:					current->center_x = real_x;
bezierautos.C:					current->center_y = real_y;
bezierautos.C:					current->center_z = real_y / virtual_h;
bezierautos.C:					current->control_in_x = real_x;
bezierautos.C:					current->control_in_y = real_y;
bezierautos.C:					current->control_out_x = real_x;
bezierautos.C:					current->control_out_y = real_y;
bezierautos.C:					current->control_in_z = real_y / virtual_h;
bezierautos.C:					current->control_out_z = real_y / virtual_h;
bezierautos.C:	new_auto->position = frame;
bezierautos.C:	new_auto->control_in_x = new_auto->control_out_x = 0;
bezierautos.C:	new_auto->control_in_y = new_auto->control_out_y = 0;
bezierautos.C:	new_auto->control_in_z = new_auto->control_out_z = 0;
bezierautos.C:	new_auto->center_x = x;
bezierautos.C:	new_auto->center_y = y;
bezierautos.C:	new_auto->center_z = z;
bezierautos.C://printf("BezierAutos::add_auto %lld\n", new_auto->position);
bezierautos.C:		current->center_x -= offsets[0];
bezierautos.C:		current->center_y -= offsets[1];
bezierautos.C:		current->center_z *= scale;
bezierautos.C:		default_auto->position, 
bezierautos.C:		((BezierAuto*)default_auto)->center_x,
bezierautos.C:		((BezierAuto*)default_auto)->center_y,
bezierautos.C:		((BezierAuto*)default_auto)->center_z);
bezierautos.C:			current->position, 
bezierautos.C:			((BezierAuto*)current)->center_x,
bezierautos.C:			((BezierAuto*)current)->center_y,
bezierautos.C:			((BezierAuto*)current)->center_z);
bitspopup.C:	this->parent_window = parent_window;
bitspopup.C:	this->output = output;
bitspopup.C:	this->x = x;
bitspopup.C:	this->y = y;
bitspopup.C:	this->use_ima4 = use_ima4;
bitspopup.C:	this->use_ulaw = use_ulaw;
bitspopup.C:	this->use_adpcm = use_adpcm;
bitspopup.C:	this->use_float = use_float;
bitspopup.C:	this->use_32linear = use_32linear;
bitspopup.C:	parent_window->add_subwindow(textbox = new BitsPopupText(this, x, y));
bitspopup.C:	x += textbox->get_w();
bitspopup.C:	parent_window->add_subwindow(menu = new BitsPopupMenu(this, x, y));
bitspopup.C:	return menu->get_w() + textbox->get_w();
bitspopup.C:	&popup->bits_items,
bitspopup.C:	this->popup = popup;
bitspopup.C:	popup->textbox->update(get_selection(0, 0)->get_text());
bitspopup.C:	popup->textbox->handle_event();
bitspopup.C: : BC_TextBox(x, y, 120, 1, File::bitstostr(*popup->output))
bitspopup.C:	this->popup = popup;
bitspopup.C:	*popup->output = File::strtobits(get_text());
brender.C:	this->mwindow = mwindow;
brender.C:	master_pid = -1;
brender.C:	timer->update();
brender.C:	thread->initialize();
brender.C:	strcpy(string, "-b");
brender.C:	new_command->copy_edl(edl);
brender.C:	new_command->command = BRenderCommand::BRENDER_RESTART;
brender.C:	thread->send_command(new_command);
brender.C:	new_command->command = BRenderCommand::BRENDER_STOP;
brender.C:	thread->send_command(new_command);
brender.C:	completion_lock->lock("BRender::stop");
brender.C:	map_lock->lock("BRender::get_last_contiguous");
brender.C:	map_lock->unlock();
brender.C:	map_lock->lock("BRender::allocate_map");
brender.C:	bzero(map + start, end - start);
brender.C:	mwindow->session->brender_end = (double)last_contiguous / 
brender.C:		mwindow->edl->session->frame_rate;
brender.C:	map_lock->unlock();
brender.C:	map_lock->lock("BRender::set_video_map");
brender.C:		mwindow->session->brender_end = (double)last_contiguous / 
brender.C:			mwindow->edl->session->frame_rate;
brender.C:		if(timer->get_difference() > 1000 || last_contiguous >= map_size)
brender.C:			timer->update();
brender.C:	map_lock->unlock();
brender.C:		mwindow->gui->lock_window();
brender.C:		mwindow->gui->timebar->update(1, 0);
brender.C:		mwindow->gui->timebar->flush();
brender.C:		mwindow->gui->unlock_window();
brender.C:	this->edl = src->edl;
brender.C:	src->edl = 0;
brender.C:	this->position = src->position;
brender.C:	this->command = src->command;
brender.C:	this->edl = new EDL;
brender.C:	this->edl->create_objects();
brender.C:	this->edl->copy_all(edl);
brender.C:	this->position = 0;
brender.C:	this->mwindow = mwindow;
brender.C:	this->brender = brender;
brender.C:	thread_lock->lock("BRenderThread::~BRenderThread");
brender.C:	input_lock->unlock();
brender.C:	thread_lock->unlock();
brender.C:	thread_lock->lock("BRenderThread::send_command");
brender.C:	if(this->command_queue)
brender.C:		delete this->command_queue;
brender.C:		this->command_queue = 0;
brender.C:	this->command_queue = command;
brender.C:	input_lock->unlock();
brender.C:	thread_lock->unlock();
brender.C:	if(do_lock) thread_lock->lock("BRenderThread::is_done");
brender.C:	if(do_lock) thread_lock->unlock();
brender.C:		thread_lock->lock("BRenderThread::run 1");
brender.C:			thread_lock->unlock();
brender.C:			input_lock->lock("BRenderThread::run 2");
brender.C:			thread_lock->lock("BRenderThread::run 3");
brender.C:		thread_lock->unlock();
brender.C:		if(new_command->command == BRenderCommand::BRENDER_STOP)
brender.C:		if(new_command->command == BRenderCommand::BRENDER_RESTART)
brender.C:			if(command && command->edl)
brender.C:				new_command->position = 
brender.C:					new_command->edl->equivalent_output(command->edl);
brender.C:				new_command->position = 0;
brender.C:			brender->completion_lock->lock("BRenderThread::run 4");
brender.C:			if(new_command->edl->tracks->total_playable_vtracks())
brender.C:		farm_server->wait_clients();
brender.C:	brender->completion_lock->unlock();
brender.C:		*preferences = *mwindow->preferences;
brender.C:		if(!preferences->use_renderfarm)
brender.C:			preferences->use_renderfarm = 1;
brender.C:			preferences->delete_nodes();
brender.C:		preferences->add_node(brender->socket_path,
brender.C:			preferences->local_rate);
brender.C://printf("BRenderThread::start 1 %s\n", brender->socket_path);
brender.C:		preferences->brender_asset->use_header = 0;
brender.C:		preferences->brender_asset->frame_rate = command->edl->session->frame_rate;
brender.C:		preferences->brender_asset->width = command->edl->session->output_w;
brender.C:		preferences->brender_asset->height = command->edl->session->output_h;
brender.C:		int brender_start = (int)(command->edl->session->brender_start *
brender.C:			command->edl->session->frame_rate);
brender.C:		int last_contiguous = brender->last_contiguous;
brender.C:		int last_good = (int)(command->edl->session->frame_rate * 
brender.C:			command->position);
brender.C:		int64_t end_frame = Units::round(command->edl->tracks->total_video_length() * 
brender.C:			command->edl->session->frame_rate);
brender.C:		brender->allocate_map(brender_start, start_frame, end_frame);
brender.C:		result = packages->create_packages(mwindow,
brender.C:			command->edl,
brender.C:			preferences->brender_asset, 
brender.C:			(double)start_frame / command->edl->session->frame_rate, 
brender.C:			(double)end_frame / command->edl->session->frame_rate,
brender.C:			preferences->brender_asset,
brender.C:			command->edl,
brender.C:		result = farm_server->start_clients();
brender.C:// No-one must be retrieving a package when packages are deleted.
browsebutton.C: : BC_Button(x, y, mwindow->theme->magnify_button_data), 
browsebutton.C:	this->parent_window = parent_window;
browsebutton.C:	this->want_directory = want_directory;
browsebutton.C:	this->title = title;
browsebutton.C:	this->caption = caption;
browsebutton.C:	this->init_directory = init_directory;
browsebutton.C:	this->textbox = textbox;
browsebutton.C:	this->mwindow = mwindow;
browsebutton.C:	startup_lock->lock();
browsebutton.C:		gui->lock_window();
browsebutton.C:		gui->set_done(1);
browsebutton.C:		gui->unlock_window();
browsebutton.C:	startup_lock->unlock();
browsebutton.C:			gui->lock_window();
browsebutton.C:			gui->raise_window();
browsebutton.C:			gui->unlock_window();
browsebutton.C:	x = parent_window->get_abs_cursor_x();
browsebutton.C:	y = parent_window->get_abs_cursor_y();
browsebutton.C:	startup_lock->lock();
browsebutton.C:	startup_lock->lock();
browsebutton.C:	startup_lock->unlock();
browsebutton.C:		textbox->get_text(), 
browsebutton.C:	startup_lock->unlock();
browsebutton.C:// 			textbox->update(browsewindow.get_directory());
browsebutton.C:// 			textbox->update(browsewindow.get_filename());
browsebutton.C:		textbox->update(browsewindow.get_submitted_path());
browsebutton.C:		parent_window->flush();
browsebutton.C:		textbox->handle_event();
browsebutton.C:	startup_lock->lock();
browsebutton.C:	startup_lock->unlock();
browsebutton.C: : BC_FileBox(button->x - 
browsebutton.C: 		BC_WindowBase::get_resources()->filebox_w / 2, 
browsebutton.C: 	button->y - 
browsebutton.C:		BC_WindowBase::get_resources()->filebox_h / 2,
browsebutton.C:	mwindow->theme->browse_pad)
byteorderpopup.C:	this->parent_window = parent_window;
byteorderpopup.C:	this->output = output;
byteorderpopup.C:	this->x = x;
byteorderpopup.C:	this->y = y;
byteorderpopup.C:	parent_window->add_subwindow(textbox = new ByteOrderText(this, x, y));
byteorderpopup.C:	x += textbox->get_w();
byteorderpopup.C:	parent_window->add_subwindow(menu = new ByteOrderList(this, x, y));
byteorderpopup.C:	&popup->byteorder_items,
byteorderpopup.C:	this->popup = popup;
byteorderpopup.C:	popup->textbox->update(get_selection(0, 0)->get_text());
byteorderpopup.C:	popup->textbox->handle_event();
byteorderpopup.C: : BC_TextBox(x, y, 100, 1, File::byteorder_to_str(*popup->output))
byteorderpopup.C:	this->popup = popup;
byteorderpopup.C:	*popup->output = File::str_to_byteorder(get_text());
cache.C:	this->edl = new EDL;
cache.C:	this->edl->create_objects();
cache.C:	*this->edl = *edl;
cache.C:	this->plugindb = plugindb;
cache.C:	this->preferences = preferences;
cache.C:	*this->edl = *edl;
cache.C:		if(!current->asset->test_path(file->asset->path))
cache.C:			if(file != current->file)
cache.C:				file = current->file;
cache.C:	item->asset = new Asset(*(file->asset));
cache.C:	file->set_asset(item->asset);
cache.C:	check_out_lock->lock("CICache::check_out");
cache.C:		if(!strcmp(current->asset->path, asset->path))
cache.C:			current->counter = 0;
cache.C:		if(new_item->file)
cache.C:			new_item->item_lock->lock();
cache.C:			new_item->checked_out = 1;
cache.C:			result = new_item->file;
cache.C:	check_out_lock->unlock();
cache.C:	check_in_lock->lock();
cache.C:	total_lock->lock("CICache::check_in");
cache.C:		if(!strcmp(current->asset->path, asset->path))
cache.C:			current->checked_out = 0;
cache.C:			current->item_lock->unlock();
cache.C:	total_lock->unlock();
cache.C:	check_in_lock->unlock();
cache.C:	Asset *asset = edl->assets->get_asset(path);
cache.C:		if(current->asset->equivalent(*asset, 0, 0))
cache.C:			if(!current->checked_out)
cache.C:	check_out_lock->lock("CICache::age");
cache.C:		current->counter++;
cache.C:		if(memory_usage > preferences->cache_size)
cache.C:	}while(memory_usage > preferences->cache_size && !result);
cache.C:	check_out_lock->unlock();
cache.C:		if(current->counter >= highest_counter)
cache.C:			highest_counter = current->counter;
cache.C:	if(highest_counter > 1 && oldest && !oldest->checked_out)
cache.C:		total_lock->lock("CICache::delete_oldest");
cache.C:		total_lock->unlock();
cache.C:		printf("	asset %x\n", current->asset);
cache.C:		printf("	%s\n", current->asset->path);
cache.C:		printf("	counter %lld\n", current->counter);
cache.C:	check_in_lock->lock("CICache::lock_all");
cache.C:	check_out_lock->lock("CICache::lock_all");
cache.C:	check_in_lock->unlock();
cache.C:	check_out_lock->unlock();
cache.C:	this->asset = new Asset;
cache.C:	*this->asset = *asset;
cache.C:	this->cache = cache;
cache.C:	file->set_processors(cache->preferences->processors);
cache.C:	file->set_preload(cache->edl->session->playback_preload);
cache.C:	this->asset->divx_use_deblocking = cache->edl->session->mpeg4_deblock;
cache.C:	if(result = file->open_file(cache->plugindb, this->asset, 1, 0, -1, -1))
cache.C:	this->asset = new Asset;
cache.C:	*this->asset = *file->asset;
cache.C:	this->file = file;
cache.C:	this->cache = cache;
cache.C:	file->set_processors(cache->preferences->processors);
cache.C:	file->set_preload(cache->edl->session->playback_preload);
canvas.C:	this->subwindow = subwindow;
canvas.C:	this->x = x;
canvas.C:	this->y = y;
canvas.C:	this->w = w;
canvas.C:	this->h = h;
canvas.C:	this->output_w = output_w;
canvas.C:	this->output_h = output_h;
canvas.C:	this->use_scrollbars = use_scrollbars;
canvas.C:	this->use_cwindow = use_cwindow;
canvas.C:	this->use_rwindow = use_rwindow;
canvas.C:	this->use_vwindow = use_vwindow;
canvas.C:				return -(float)(w_visible - conformed_w) / 2;
canvas.C:			return ((float)-canvas->get_w() / zoom_x + 
canvas.C:				edl->calculate_output_w(single_channel)) / 2;
canvas.C:		int canvas_w = canvas->get_w();
canvas.C:		int canvas_h = canvas->get_h();
canvas.C:			return -(canvas_w - out_w) / 2 / zoom_x;
canvas.C:				return -(float)(h_visible - conformed_h) / 2;
canvas.C:			return ((float)-canvas->get_h() / zoom_y + 
canvas.C:				edl->calculate_output_h(single_channel)) / 2;
canvas.C:		int canvas_w = canvas->get_w();
canvas.C:		int canvas_h = canvas->get_h();
canvas.C://printf("Canvas::get_y_offset 1 %d %d %f\n", out_h, canvas_h, -((float)canvas_h - out_h) / 2);
canvas.C:			return -((float)canvas_h - out_h) / 2 / zoom_y;
canvas.C:	if(x + w_visible > w_needed) x = w_needed - w_visible;
canvas.C:	if(y + h_visible > h_needed) y = h_needed - h_visible;
canvas.C:		if(xscroll) xscroll->update_length(w_needed, get_xscroll(), w_visible);
canvas.C:		if(yscroll) yscroll->update_length(h_needed, get_yscroll(), h_visible);
canvas.C:	edl->calculate_conformed_dimensions(single_channel, 
canvas.C:			edl->calculate_output_w(single_channel);
canvas.C:			edl->calculate_output_h(single_channel);
canvas.C:		int canvas_w = canvas->get_w();
canvas.C:		int canvas_h = canvas->get_h();
canvas.C:		zoom_x = (float)out_w / edl->calculate_output_w(single_channel);
canvas.C:		zoom_y = (float)out_h / edl->calculate_output_h(single_channel);
canvas.C:	x = (float)zoom_x * (x - get_x_offset(edl, single_channel, zoom_x, conformed_w, conformed_h));
canvas.C:	y = (float)zoom_y * (y - get_y_offset(edl, single_channel, zoom_y, conformed_w, conformed_h));
canvas.C:	if(canvas_w < 0) canvas_w = canvas->get_w();
canvas.C:	if(canvas_h < 0) canvas_h = canvas->get_h();
canvas.C:// printf("Canvas::get_transfers 1 %.0f %.0f %.0f %.0f -> %.0f %.0f %.0f %.0f\n",
canvas.C:			out_x1 += -in_x1 * zoom_x;
canvas.C:			out_y1 += -in_y1 * zoom_y;
canvas.C:			out_x2 -= (in_x2 - output_w) * zoom_x;
canvas.C:			out_y2 -= (in_y2 - output_h) * zoom_y;
canvas.C:// printf("Canvas::get_transfers 2 %.0f %.0f %.0f %.0f -> %.0f %.0f %.0f %.0f\n",
canvas.C:		in_w = (int)(in_x2 - in_x1);
canvas.C:		in_h = (int)(in_y2 - in_y1);
canvas.C:		out_w = (int)(out_x2 - out_x1);
canvas.C:		out_h = (int)(out_y2 - out_y1);
canvas.C://			out_x = canvas_w / 2 - out_w / 2;
canvas.C://			out_y = canvas_h / 2 - out_h / 2;
canvas.C:// printf("Canvas::get_transfers 2 %d %d %d %d -> %d %d %d %d\n",in_x, 
canvas.C:			if((float)out_w / out_h > edl->get_aspect_ratio())
canvas.C:				out_w = (int)(out_h * edl->get_aspect_ratio() + 0.5);
canvas.C:				out_x = canvas_w / 2 - out_w / 2;
canvas.C:				out_h = (int)(out_w / edl->get_aspect_ratio() + 0.5);
canvas.C:				out_y = canvas_h / 2 - out_h / 2;
canvas.C:			in_w = this->output_w;
canvas.C:			in_h = this->output_h;
canvas.C:		return edl->calculate_output_w(0);
canvas.C:		return edl->session->output_w;
canvas.C:			return edl->calculate_output_h(0);
canvas.C:			return edl->session->output_h;
canvas.C:		w_needed = edl->calculate_output_w(0);
canvas.C:		h_needed = edl->calculate_output_h(0);
canvas.C:		w_needed = edl->calculate_output_w(0);
canvas.C:		h_needed = edl->calculate_output_h(0);
canvas.C:					canvas_h -= BC_ScrollBar::get_span(SCROLL_HORIZ);
canvas.C:					canvas_w -= BC_ScrollBar::get_span(SCROLL_VERT);
canvas.C:			subwindow->add_subwindow(xscroll = new CanvasXScroll(edl, 
canvas.C:			xscroll->reposition_window(canvas_x, canvas_y + canvas_h, canvas_w);
canvas.C:		if(xscroll->get_length() != w_needed ||
canvas.C:			xscroll->get_handlelength() != w_visible)
canvas.C:			xscroll->update_length(w_needed, get_xscroll(), w_visible);
canvas.C:			subwindow->add_subwindow(yscroll = new CanvasYScroll(edl, 
canvas.C:			yscroll->reposition_window(canvas_x + canvas_w, canvas_y, canvas_h);
canvas.C:		if(yscroll->get_length() != edl->calculate_output_h(0) ||
canvas.C:			yscroll->get_handlelength() != h_visible)
canvas.C:			yscroll->update_length(h_needed, get_yscroll(), h_visible);
canvas.C:	this->x = x;
canvas.C:	this->y = y;
canvas.C:	this->w = w;
canvas.C:	this->h = h;
canvas.C:	canvas->reposition_window(view_x, view_y, view_w, view_h);
canvas.C:	canvas->set_cursor(cursor);
canvas.C:	return canvas->get_cursor_x();
canvas.C:	return canvas->get_cursor_y();
canvas.C:	return canvas->get_buttonpress();
canvas.C:	subwindow->add_subwindow(canvas = new CanvasOutput(edl, 
canvas.C:	subwindow->add_subwindow(canvas_menu = new CanvasPopup(this));
canvas.C:	canvas_menu->create_objects();
canvas.C:	if(canvas->get_buttonpress() == 3)
canvas.C:		canvas_menu->activate_menu();
canvas.C:	this->canvas = canvas;
canvas.C:	if(cursor_inside) result = canvas->cursor_leave_event();
canvas.C:		result = canvas->cursor_enter_event();
canvas.C:		return canvas->button_press_event();
canvas.C:	return canvas->button_release_event();
canvas.C:	return canvas->cursor_motion_event();
canvas.C:	this->canvas = canvas;
canvas.C:	canvas->update_zoom(get_value(), canvas->get_yscroll(), canvas->get_zoom());
canvas.C:	canvas->draw_refresh();
canvas.C:	this->canvas = canvas;
canvas.C:	canvas->update_zoom(canvas->get_xscroll(), get_value(), canvas->get_zoom());
canvas.C:	canvas->draw_refresh();
canvas.C:	this->canvas = canvas;
canvas.C:	if(canvas->use_cwindow)
canvas.C:	if(canvas->use_rwindow)
canvas.C:	if(canvas->use_vwindow)
canvas.C:	this->canvas = canvas;
canvas.C:	this->percentage = percentage;
canvas.C:	canvas->zoom_resize_window(percentage);
canvas.C:	this->canvas = canvas;
canvas.C:	canvas->reset_camera();
canvas.C:	this->canvas = canvas;
canvas.C:	canvas->reset_projector();
canvas.C:	this->canvas = canvas;
canvas.C:	canvas->reset_translation();
canvas.C:	this->canvas = canvas;
canvas.C:	canvas->close_source();
canvastools.C:	this->mwindow = mwindow;
canvastools.C:	this->trackcanvas = trackcanvas;
canvastools.C:	this->edit = edit;
canvastools.C:	this->mwindow = mwindow;
canvastools.C:	this->trackcanvas = trackcanvas;
canvastools.C:		values[i]->visible--;
canvastools.C:	for(int i = total - 1; i >= 0; i--)
canvastools.C:		if(values[i]->visible < 1)
canvastools.C:	return MWindowGUI::visible(x, x + w, 0, trackcanvas->get_w()) &&
canvastools.C:		MWindowGUI::visible(y, y + h, 0, trackcanvas->get_h());
channel.C:	strcpy(this->title, "");
channel.C:	this->entry = 0;
channel.C:	this->freqtable = 0;
channel.C:	this->fine_tune = 0;
channel.C:	this->input = 0;
channel.C:	this->norm = 0;
channel.C:	strcpy(this->title, channel->title);
channel.C:	this->entry = channel->entry;
channel.C:	this->freqtable = channel->freqtable;
channel.C:	this->fine_tune = channel->fine_tune;
channel.C:	this->input = channel->input;
channel.C:	this->norm = channel->norm;
channel.C:	strcpy(this->title, channel.title);
channel.C:	this->entry = channel.entry;
channel.C:	this->freqtable = channel.freqtable;
channel.C:	this->fine_tune = channel.fine_tune;
channel.C:	this->input = channel.input;
channel.C:	this->norm = channel.norm;
channel.C:		done = file->read_tag();
channel.C:			if(file->tag.title_is("CHANNEL"))
channel.C:				entry = file->tag.get_property("ENTRY", entry);
channel.C:				freqtable = file->tag.get_property("FREQTABLE", freqtable);
channel.C:				fine_tune = file->tag.get_property("FINE_TUNE", fine_tune);
channel.C:				input = file->tag.get_property("INPUT", input);
channel.C:				norm = file->tag.get_property("NORM", norm);
channel.C:				text = file->read_text();
channel.C:			if(file->tag.title_is("/CHANNEL"))
channel.C:	file->tag.set_title("CHANNEL");
channel.C:	file->tag.set_property("ENTRY", entry);
channel.C:	file->tag.set_property("FREQTABLE", freqtable);
channel.C:	file->tag.set_property("FINE_TUNE", fine_tune);
channel.C:	file->tag.set_property("INPUT", input);
channel.C:	file->tag.set_property("NORM", norm);
channel.C:	file->append_tag();
channel.C:	file->append_text(title);
channel.C:	file->tag.set_title("/CHANNEL");
channel.C:	file->append_tag();
channel.C:	file->append_newline();
channeledit.C:	this->channel_picker = channel_picker;
channeledit.C:	this->mwindow = mwindow;
channeledit.C:	this->channeldb = channeldb;
channeledit.C:	this->record = record;
channeledit.C:	this->window = 0;
channeledit.C:			window->lock_window();
channeledit.C:			window->raise_window();
channeledit.C:			window->flush();
channeledit.C:			window->unlock_window();
channeledit.C:	for(i = 0; i < channel_picker->channeldb->total; i++)
channeledit.C:		new_channels->append(new Channel(channel_picker->channeldb->values[i]));
channeledit.C:	current_channel = channel_picker->get_current_channel_number();
channeledit.C:	this->window = &window;
channeledit.C:	this->window = 0;
channeledit.C:		channel_picker->channeldb->remove_all_objects();
channeledit.C:		for(i = 0; i < new_channels->total; i++)
channeledit.C:			channel_picker->channeldb->append(new Channel(new_channels->values[i]));
channeledit.C:		channel_picker->update_channel_list();
channeledit.C:			record->record_gui->lock_window();
channeledit.C:			record->record_gui->update_batch_sources();
channeledit.C:			record->set_channel(current_channel);
channeledit.C:			record->record_gui->unlock_window();
channeledit.C:			record->save_defaults();
channeledit.C:		mwindow->save_defaults();
channeledit.C:			record->set_channel(record->get_editing_batch()->channel);
channeledit.C:	window.edit_thread->close_threads();
channeledit.C:	window.picture_thread->close_threads();
channeledit.C:	new_channels->remove_all_objects();
channeledit.C:		window->edit_thread->close_threads();
channeledit.C:		window->picture_thread->close_threads();
channeledit.C:		window->set_done(1);
channeledit.C: 	mwindow->gui->get_abs_cursor_x() - 330, 
channeledit.C:	mwindow->gui->get_abs_cursor_y(), 
channeledit.C:	this->thread = thread;
channeledit.C:	this->channel_picker = channel_picker;
channeledit.C:	this->mwindow = mwindow;
channeledit.C:	for(i = 0; i < thread->new_channels->total; i++)
channeledit.C:		channel_list.append(new BC_ListBoxItem(thread->new_channels->values[i]->title));
channeledit.C:	if(thread->record)
channeledit.C:		thread->record);
channeledit.C:	if(thread->new_channels->total) *new_channel = *(thread->new_channels->values[thread->new_channels->total - 1]);
channeledit.C:	channel_list.append(new BC_ListBoxItem(new_channel->title));
channeledit.C:	thread->new_channels->append(new_channel);
channeledit.C:	edit_thread->edit_channel(new_channel, 0);
channeledit.C:	list_box->update(&channel_list, 0, 0, 1, list_box->get_yposition());
channeledit.C:	for(i = 0; i < thread->new_channels->total; i++)
channeledit.C:		if(thread->new_channels->values[i] == channel) break;
channeledit.C:	if(i < thread->new_channels->total)
channeledit.C:		channel_list.values[i]->set_text(channel->title);
channeledit.C:	if(list_box->get_selection_number(0, 0) > -1)
channeledit.C:		edit_thread->edit_channel(thread->new_channels->values[list_box->get_selection_number(0, 0)], 1);
channeledit.C:	picture_thread->edit_picture();
channeledit.C:	delete thread->new_channels->values[number];
channeledit.C:	thread->new_channels->remove_number(number);
channeledit.C:	for(i = 0; i < thread->new_channels->total; i++)
channeledit.C:		if(thread->new_channels->values[i] == channel)
channeledit.C:	if(i < thread->new_channels->total) delete_channel(i);
channeledit.C:	if(list_box->get_selection_number(0, 0) > -1)
channeledit.C:		int number2 = list_box->get_selection_number(0, 0);
channeledit.C:		int number1 = number2 - 1;
channeledit.C:		if(number1 < 0) number1 = thread->new_channels->total - 1;
channeledit.C:		temp = thread->new_channels->values[number1];
channeledit.C:		thread->new_channels->values[number1] = thread->new_channels->values[number2];
channeledit.C:		thread->new_channels->values[number2] = temp;
channeledit.C:		list_box->update(&channel_list, 
channeledit.C:			list_box->get_xposition(), 
channeledit.C:			list_box->get_yposition(), 
channeledit.C:	if(list_box->get_selection_number(0, 0) > -1)
channeledit.C:		int number2 = list_box->get_selection_number(0, 0);
channeledit.C:		if(number1 > thread->new_channels->total - 1) number1 = 0;
channeledit.C:		temp = thread->new_channels->values[number1];
channeledit.C:		thread->new_channels->values[number1] = thread->new_channels->values[number2];
channeledit.C:		thread->new_channels->values[number2] = temp;
channeledit.C:		list_box->update(&channel_list, 
channeledit.C:			list_box->get_xposition(), 
channeledit.C:			list_box->get_yposition(), 
channeledit.C:	if(channel_number > -1 && channel_number < thread->new_channels->total)
channeledit.C:		thread->current_channel = channel_number;
channeledit.C:		channel_picker->set_channel(thread->new_channels->values[channel_number]);
channeledit.C:	this->window = window;
channeledit.C:	window->change_channel_from_list(
channeledit.C:		window->list_box->get_selection_number(0, 0));
channeledit.C:	this->window = window;
channeledit.C:	window->add_channel();
channeledit.C:			&(window->channel_list))
channeledit.C:	this->window = window;
channeledit.C:	window->edit_channel();
channeledit.C:	this->window = window;
channeledit.C:	window->move_channel_up();
channeledit.C:	this->window = window;
channeledit.C:	window->move_channel_down();
channeledit.C:	this->window = window;
channeledit.C:	if(window->list_box->get_selection_number(0, 0) > -1) window->delete_channel(window->list_box->get_selection_number(0, 0));
channeledit.C:	this->window = window;
channeledit.C:	window->edit_channel();
channeledit.C:	this->window = window;
channeledit.C:	window->edit_picture();
channeledit.C:	this->window = window;
channeledit.C:	this->channel_picker = channel_picker;
channeledit.C:	this->record = record;
channeledit.C:		edit_window->set_done(1);
channeledit.C:	this->editing = editing;
channeledit.C:	this->output_channel = channel;
channeledit.C:	this->new_channel = *output_channel;
channeledit.C:	if(channel_picker->get_video_inputs()->total > value)
channeledit.C:		return channel_picker->get_video_inputs()->values[value];
channeledit.C:	channel_picker->set_channel(&new_channel);
channeledit.C:	if(new_channel.entry > chanlists[new_channel.freqtable].count - 1) new_channel.entry = 0;
channeledit.C:	source_text->update(chanlists[new_channel.freqtable].list[new_channel.entry].name);
channeledit.C:	new_channel.entry--;
channeledit.C:	if(new_channel.entry < 0) new_channel.entry = chanlists[new_channel.freqtable].count - 1;
channeledit.C:	source_text->update(chanlists[new_channel.freqtable].list[new_channel.entry].name);
channeledit.C:	if(new_channel.entry > chanlists[new_channel.freqtable].count - 1) new_channel.entry = 0;
channeledit.C:	source_text->update(chanlists[new_channel.freqtable].list[new_channel.entry].name);
channeledit.C:	this->edit_window = &edit_window;
channeledit.C:	this->edit_window = 0;
channeledit.C:		window->lock_window();
channeledit.C:		window->update_list(output_channel);
channeledit.C:		window->unlock_window();
channeledit.C:			window->lock_window();
channeledit.C:			window->delete_channel(output_channel);
channeledit.C:			window->unlock_window();
channeledit.C: 	channel_picker->mwindow->gui->get_abs_cursor_x(), 
channeledit.C:	channel_picker->mwindow->gui->get_abs_cursor_y(), 
channeledit.C:	this->channel_picker = channel_picker;
channeledit.C:	this->window = window;
channeledit.C:	this->thread = thread;
channeledit.C:	this->new_channel = channel;
channeledit.C:	add_subwindow(thread->source_text = new ChannelEditEditSource(x, y, thread));
channeledit.C:	norm->add_items();
channeledit.C:	table->add_items();
channeledit.C:	add_subwindow(input = new ChannelEditEditInput(x + 130, y, thread, thread->record));
channeledit.C:	input->add_items();
channeledit.C: : BC_TextBox(x, y, 150, 1, thread->new_channel.title)
channeledit.C:	this->thread = thread;
channeledit.C:		strcpy(thread->new_channel.title, get_text());
channeledit.C: : BC_TextBox(x, y, 150, 1, chanlists[thread->new_channel.freqtable].list[thread->new_channel.entry].name)
channeledit.C:	this->thread = thread;
channeledit.C:	thread->change_source(get_text());
channeledit.C:	this->thread = thread;
channeledit.C:	thread->source_up();
channeledit.C:	thread->source_down();
channeledit.C: : BC_PopupMenu(x, y, 150, thread->value_to_input(thread->new_channel.input))
channeledit.C:	this->thread = thread;
channeledit.C:	this->record = record;
channeledit.C:	inputs = thread->channel_picker->get_video_inputs();
channeledit.C:		for(int i = 0; i < inputs->total; i++)
channeledit.C:			add_item(new ChannelEditEditInputItem(thread, inputs->values[i], i));
channeledit.C:	this->thread = thread;
channeledit.C:	this->value = value;
channeledit.C:	get_popup_menu()->set_text(get_text());
channeledit.C:	thread->set_input(value);
channeledit.C: : BC_PopupMenu(x, y, 100, thread->value_to_norm(thread->new_channel.norm))
channeledit.C:	this->thread = thread;
channeledit.C:	add_item(new ChannelEditEditNormItem(thread, thread->value_to_norm(NTSC), NTSC));
channeledit.C:	add_item(new ChannelEditEditNormItem(thread, thread->value_to_norm(PAL), PAL));
channeledit.C:	add_item(new ChannelEditEditNormItem(thread, thread->value_to_norm(SECAM), SECAM));
channeledit.C:	this->value = value;
channeledit.C:	this->thread = thread;
channeledit.C:	get_popup_menu()->set_text(get_text());
channeledit.C:	thread->set_norm(value);
channeledit.C: : BC_PopupMenu(x, y, 150, thread->value_to_freqtable(thread->new_channel.freqtable))
channeledit.C:	this->thread = thread;
channeledit.C:	add_item(new ChannelEditEditFreqItem(thread, thread->value_to_freqtable(NTSC_BCAST), NTSC_BCAST));
channeledit.C:	add_item(new ChannelEditEditFreqItem(thread, thread->value_to_freqtable(NTSC_CABLE), NTSC_CABLE));
channeledit.C:	add_item(new ChannelEditEditFreqItem(thread, thread->value_to_freqtable(NTSC_HRC), NTSC_HRC));
channeledit.C:	add_item(new ChannelEditEditFreqItem(thread, thread->value_to_freqtable(NTSC_BCAST_JP), NTSC_BCAST_JP));
channeledit.C:	add_item(new ChannelEditEditFreqItem(thread, thread->value_to_freqtable(NTSC_CABLE_JP), NTSC_CABLE_JP));
channeledit.C:	add_item(new ChannelEditEditFreqItem(thread, thread->value_to_freqtable(PAL_AUSTRALIA), PAL_AUSTRALIA));
channeledit.C:	add_item(new ChannelEditEditFreqItem(thread, thread->value_to_freqtable(PAL_EUROPE), PAL_EUROPE));
channeledit.C:	add_item(new ChannelEditEditFreqItem(thread, thread->value_to_freqtable(PAL_E_EUROPE), PAL_E_EUROPE));
channeledit.C:	add_item(new ChannelEditEditFreqItem(thread, thread->value_to_freqtable(PAL_ITALY), PAL_ITALY));
channeledit.C:	add_item(new ChannelEditEditFreqItem(thread, thread->value_to_freqtable(PAL_IRELAND), PAL_IRELAND));
channeledit.C:	add_item(new ChannelEditEditFreqItem(thread, thread->value_to_freqtable(PAL_NEWZEALAND), PAL_NEWZEALAND));
channeledit.C:	this->value = value;
channeledit.C:	this->thread = thread;
channeledit.C:	get_popup_menu()->set_text(get_text());
channeledit.C:	thread->set_freqtable(value);
channeledit.C:		-100, 
channeledit.C:		thread->new_channel.fine_tune)
channeledit.C:	this->thread = thread;
channeledit.C:	thread->new_channel.fine_tune = get_value();
channeledit.C:	thread->set_device();
channeledit.C:	this->channel_picker = channel_picker;
channeledit.C:	this->window = window;
channeledit.C:	this->edit_window = &edit_window;
channeledit.C:	this->edit_window = 0;
channeledit.C:		edit_window->set_done(1);
channeledit.C: 	channel_picker->mwindow->gui->get_abs_cursor_x() - 200, 
channeledit.C:	channel_picker->mwindow->gui->get_abs_cursor_y() - 220, 
channeledit.C:	this->thread = thread;
channeledit.C:	this->channel_picker = channel_picker;
channeledit.C:	add_subwindow(new ChannelEditBright(x + 100, y, channel_picker, channel_picker->get_brightness()));
channeledit.C:	add_subwindow(new ChannelEditContrast(x + 135, y, channel_picker, channel_picker->get_contrast()));
channeledit.C:	add_subwindow(new ChannelEditColor(x + 100, y, channel_picker, channel_picker->get_color()));
channeledit.C:	add_subwindow(new ChannelEditHue(x + 135, y, channel_picker, channel_picker->get_hue()));
channeledit.C:	add_subwindow(new ChannelEditWhiteness(x + 100, y, channel_picker, channel_picker->get_whiteness()));
channeledit.C:		-100, 
channeledit.C:	this->channel_picker = channel_picker;
channeledit.C:	channel_picker->set_brightness(get_value());
channeledit.C:		-100, 
channeledit.C:	this->channel_picker = channel_picker;
channeledit.C:	channel_picker->set_contrast(get_value());
channeledit.C:		-100, 
channeledit.C:	this->channel_picker = channel_picker;
channeledit.C:	channel_picker->set_color(get_value());
channeledit.C:		-100, 
channeledit.C:	this->channel_picker = channel_picker;
channeledit.C:	channel_picker->set_hue(get_value());
channeledit.C:		-100, 
channeledit.C:	this->channel_picker = channel_picker;
channeledit.C:	channel_picker->set_whiteness(get_value());
channelpicker.C:	this->prefs = prefs;
channelpicker.C:	return prefs->dialog;
channelpicker.C:	if(number >= 0 && number < channeldb->total)
channelpicker.C:		return channeldb->values[number];
channelpicker.C:	return prefs->out_config->buz_out_channel;
channelpicker.C:		channel_text->update(channel->title);
channelpicker.C:	CLAMP(number, 0, channeldb->total - 1);
channelpicker.C:	prefs->out_config->buz_out_channel = number;
channelpicker.C:	prefs->out_config->brightness = value;
channelpicker.C:	prefs->out_config->hue = value;
channelpicker.C:	prefs->out_config->color = value;
channelpicker.C:	prefs->out_config->contrast = value;
channelpicker.C:	prefs->out_config->whiteness = value;
channelpicker.C:	return prefs->out_config->brightness;
channelpicker.C:	return prefs->out_config->hue;
channelpicker.C:	return prefs->out_config->color;
channelpicker.C:	return prefs->out_config->contrast;
channelpicker.C:	return prefs->out_config->whiteness;
channelpicker.C:	this->mwindow = mwindow;
channelpicker.C:	this->record = record;
channelpicker.C:	this->record_monitor = record_monitor;
channelpicker.C:	this->x = x;
channelpicker.C:	this->y = y;
channelpicker.C:	this->channeldb = channeldb;
channelpicker.C:	for(int i = 0; i < channeldb->total; i++)
channelpicker.C:		channel_listitems.append(new BC_ListBoxItem(channeldb->values[i]->title));
channelpicker.C:		channel_text->update_list(&channel_listitems);
channelpicker.C:	return record_monitor->window;
channelpicker.C:	return record->get_current_channel_struct();
channelpicker.C:	return record->get_editing_channel();
channelpicker.C:	return record->get_video_inputs();
channelpicker.C:	record->set_channel(number);
channelpicker.C:	record->set_channel(channel);
channelpicker.C:	record->video_brightness = value;
channelpicker.C:	record->set_video_picture();
channelpicker.C:	record->video_hue = value;
channelpicker.C:	record->set_video_picture();
channelpicker.C:	record->video_color = value;
channelpicker.C:	record->set_video_picture();
channelpicker.C:	record->video_contrast = value;
channelpicker.C:	record->set_video_picture();
channelpicker.C:	record->video_whiteness = value;
channelpicker.C:	record->set_video_picture();
channelpicker.C:	return record->video_brightness;
channelpicker.C:	return record->video_hue;
channelpicker.C:	return record->video_color;
channelpicker.C:	return record->video_contrast;
channelpicker.C:	return record->video_whiteness;
channelpicker.C:	channel_text->create_objects();
channelpicker.C:	x += channel_text->get_w();
channelpicker.C:	get_subwindow()->add_subwindow(channel_select = new ChannelTumbler(mwindow, this, x, y));
channelpicker.C:	x += channel_select->get_w() + 5;
channelpicker.C:	get_subwindow()->add_subwindow(channel_button = new ChannelButton(mwindow, this, x, y - 1));
channelpicker.C:	channel_text->reposition_window(channel_text->get_x(),
channelpicker.C:		channel_text->get_y());
channelpicker.C:	channel_select->reposition_window(channel_select->get_x(),
channelpicker.C:		channel_select->get_y());
channelpicker.C:	channel_button->reposition_window(channel_button->get_x(),
channelpicker.C:		channel_button->get_y());
channelpicker.C:	channel_button->thread->close_threads();
channelpicker.C:	if(channel->entry < chanlists[channel->freqtable].count)
channelpicker.C:		return chanlists[channel->freqtable].list[channel->entry].name;
channelpicker.C:		return chanlists[channel->freqtable].list[0].name;
channelpicker.C:		return get_current_channel_struct()->title;
channelpicker.C:	int number = get_current_channel_number() - 1;
channelpicker.C:	CLAMP(number, 0, channeldb->total - 1);
channelpicker.C:	if(number >= channeldb->total) number = channeldb->total - 1;
channelpicker.C:	CLAMP(number, 0, channeldb->total - 1);
channelpicker.C: : BC_Button(x, y, mwindow->theme->channel_data)
channelpicker.C:	this->channel_picker = channel_picker;
channelpicker.C:	this->mwindow = mwindow;
channelpicker.C:		channel_picker->channeldb,
channelpicker.C:		channel_picker->record);
channelpicker.C:	thread->start();
channelpicker.C: : BC_PopupTextBox(channel_picker->get_subwindow(),
channelpicker.C: 	&channel_picker->channel_listitems,
channelpicker.C:	channel_picker->current_channel_name(),
channelpicker.C:	this->channel_picker = channel_picker;
channelpicker.C:	this->mwindow = mwindow;
channelpicker.C:	channel_picker->set_channel_number(get_number());
channelpicker.C:		&channel_picker->channel_listitems, // Each column has an ArrayList of BC_ListBoxItems.
channelpicker.C:	this->mwindow = mwindow;
channelpicker.C:	this->channel_picker = channel_picker;
channelpicker.C:	this->mwindow = mwindow;
channelpicker.C:	this->channel_picker = channel_picker;
channelpicker.C:	channel_picker->channel_up();
channelpicker.C:	channel_picker->channel_down();
chantables.C:    { "ntsc-bcast",      ntsc_bcast,      CHAN_COUNT(ntsc_bcast)      },
chantables.C:    { "ntsc-cable",      ntsc_cable,      CHAN_COUNT(ntsc_cable)      },
chantables.C:    { "ntsc-cable-hrc",  ntsc_hrc,        CHAN_COUNT(ntsc_hrc)        },
chantables.C:    { "ntsc-bcast-jp",   ntsc_bcast_jp,   CHAN_COUNT(ntsc_bcast_jp)   },
chantables.C:    { "ntsc-cable-jp",   ntsc_cable_jp,   CHAN_COUNT(ntsc_cable_jp)   },
chantables.C:    { "pal-europe",      pal_europe,      CHAN_COUNT(pal_europe)      },
chantables.C:    { "pal-europe-east", pal_europe_east, CHAN_COUNT(pal_europe_east) },
chantables.C:    { "pal-italy",       pal_italy,       CHAN_COUNT(pal_italy)       },
chantables.C:    { "pal-newzealand",  pal_newzealand,  CHAN_COUNT(pal_newzealand)  },
chantables.C:    { "pal-australia",   pal_australia,   CHAN_COUNT(pal_australia)   },
chantables.C:    { "pal-ireland",     pal_ireland,     CHAN_COUNT(pal_ireland)     }
clipedit.C:	this->mwindow = mwindow;
clipedit.C:	this->awindow = awindow;
clipedit.C:	this->vwindow = vwindow;
clipedit.C:	this->clip = 0;
clipedit.C:	this->create_it = 0;
clipedit.C:		this->clip = clip;
clipedit.C:		this->create_it = 0;
clipedit.C:		this->clip = clip;
clipedit.C:		this->create_it = 1;
clipedit.C:			clip = new EDL(mwindow->edl);
clipedit.C:			clip->create_objects();
clipedit.C:			clip->copy_all(original);
clipedit.C:		window->create_objects();
clipedit.C:		int result = window->run_window();
clipedit.C:				new_edl = mwindow->edl->add_clip(window->clip);
clipedit.C:				original->copy_session(clip);
clipedit.C://			mwindow->vwindow->gui->update_sources(mwindow->vwindow->gui->source->get_text());
clipedit.C:			mwindow->awindow->gui->lock_window();
clipedit.C:			mwindow->awindow->gui->update_assets();
clipedit.C:			mwindow->awindow->gui->flush();
clipedit.C:			mwindow->awindow->gui->unlock_window();
clipedit.C://				vwindow->change_source(new_edl);
clipedit.C:			mwindow->session->clip_number--;
clipedit.C:		delete window->clip;
clipedit.C: 	mwindow->gui->get_abs_cursor_x() - 400 / 2,
clipedit.C:	mwindow->gui->get_abs_cursor_y() - 350 / 2,
clipedit.C:	this->mwindow = mwindow;
clipedit.C:	this->thread = thread;
clipedit.C:	this->clip = thread->clip;
clipedit.C:	this->create_it = thread->create_it;
clipedit.C:	y += title->get_h() + 5;
clipedit.C:	add_subwindow(textbox = new ClipEditTitle(this, x1, y, get_w() - x1 * 2));
clipedit.C:	y += textbox->get_h() + 10;
clipedit.C:	y += title->get_h() + 5;
clipedit.C:		get_w() - x1 * 2, 
clipedit.C:		BC_TextBox::pixels_to_rows(this, MEDIUMFONT, get_h() - 10 - 40 - y)));
clipedit.C: : BC_TextBox(x, y, w, 1, window->clip->local_session->clip_title)
clipedit.C:	this->window = window;
clipedit.C:	strcpy(window->clip->local_session->clip_title, get_text());
clipedit.C: : BC_TextBox(x, y, w, rows, window->clip->local_session->clip_notes)
clipedit.C:	this->window = window;
clipedit.C:	strcpy(window->clip->local_session->clip_notes, get_text());
commonrender.C:	this->renderengine = renderengine;
commonrender.C://printf("CommonRender::arm_command 1 %f\n", renderengine->command->playbackstart);
commonrender.C:	current_position = tounits(renderengine->command->playbackstart, 0);
commonrender.C://printf("CommonRender::arm_command 2 %d\n", renderengine->command->playbackstart);
commonrender.C://printf("CommonRender::arm_command 3 %d\n", renderengine->command->playbackstart);
commonrender.C://printf("CommonRender::arm_command 3.1 %d\n", renderengine->command->playbackstart);
commonrender.C:		vconsole->start_playback();
commonrender.C://printf("CommonRender::arm_command 4 %d\n", renderengine->command->playbackstart);
commonrender.C:	Track *current = renderengine->edl->tracks->first;
commonrender.C:			if(current->data_type == data_type)
commonrender.C:				modules[module]->create_objects();
commonrender.C:			modules[module]->create_objects();
commonrender.C:			modules[i]->render_init();
commonrender.C:	return vconsole->test_reconfigure(position, length, last_playback);
commonrender.C:	vconsole->create_objects();
commonrender.C:	if(renderengine->command->realtime)
commonrender.C:		start_lock->lock("CommonRender::start_command");
commonrender.C:	vconsole->start_playback();
commonrender.C:	int64_t loop_end = tounits(renderengine->edl->local_session->loop_end, 1);
commonrender.C:	int64_t loop_start = tounits(renderengine->edl->local_session->loop_start, 0);
commonrender.C:	int64_t start_position = tounits(renderengine->command->start_position, 0);
commonrender.C:	int64_t end_position = tounits(renderengine->command->end_position, 1);
commonrender.C:	if(renderengine->command->single_frame() || 
commonrender.C:		(!renderengine->edl->local_session->loop_playback && 
commonrender.C:		!renderengine->command->infinite))
commonrender.C:		if(renderengine->command->get_direction() == PLAY_FORWARD)
commonrender.C:				current_render_length = end_position - current_position;
commonrender.C:			if(current_position - current_render_length <= start_position)
commonrender.C:				current_render_length = current_position - start_position;
commonrender.C:	if(!renderengine->command->single_frame() &&
commonrender.C:		renderengine->edl->local_session->loop_playback && 
commonrender.C:		!renderengine->command->infinite)
commonrender.C:		if(renderengine->command->get_direction(